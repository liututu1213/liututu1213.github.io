---
title: Cocoapods源码分析
category: Ruby
abbrlink: 31010
date: 2020-02-12 00:57:24
tags:
---

Cocoapods是开发OSX和iOS应用程序的一个第三方库的依赖管理工具，只用这个工具可以简化对组件依赖。更新过程。Cocoapods是用Ruby写的，由若干个gems组成：相关的[源码](https://github.com/CocoaPods)。

- **[CocoaPods/Specs](https://github.com/CocoaPods/Specs)**

  这是保存第三方组件podspec文件的仓库，包含了每一个第三方组件所有版本的podsepc文件。

- **[CocoaPods/CocoaPods](https://github.com/CocoaPods/CocoaPods)**

  一个面向用户的组件，每当执行`pod install`等命令时，都会调用这个组价。

- **[CocoaPods/Core](https://github.com/CocoaPods/Core)**

  提供支持与Cocoapods相关文件的处理

- **[CocoaPods/Xcodeproj](https://github.com/CocoaPods/Xcodeproj)**

  这个gem组件是用来创建和修改Xcode projects，负责所有工程文件的整合。

- [CocoaPods Downloader](https://www.rubydoc.info/gems/cocoapods-downloader): 下载器

- [CLAide](https://www.rubydoc.info/gems/claide): 命令行参数解析器

- [Molinillo](https://github.com/CocoaPods/Molinillo) 依赖分析

在Cocoapods中，所有的命令都会由`Commad`派发到对应的类。

### Debug Cocoapods

把Cocoapods相关的代码clone下来，Cocoapods项目作为入口，修改Cocoapods/Gemfile，指定每个依赖的path:

```ruby
# 声明Cocoapods对于git 仓库的依赖关系
# 兼容本地git 仓库模式开发
def cp_gem(name, repo_name, branch = 'master', path: false)
  return gem name if SKIP_UNRELEASED_VERSIONS
  # 如果path参数为true，则将在".../[repo_name]"这个路径下搜索仓库
  opts = if path
           { :path => "../#{repo_name}" }
         else
           url = "https://github.com/CocoaPods/#{repo_name}.git"
           { :git => url, :branch => branch }
         end
  # 返回标准的Gemfile Gem 导入格式
  gem name, opts
end

source 'https://rubygems.org'

gemspec

gem 'json', :git => 'https://github.com/segiddins/json.git', :branch => 'seg-1.7.7-ruby-2.2'

group :development do
  cp_gem 'claide',                'CLAide', path: 'CLAide'
  cp_gem 'cocoapods-core',        'Core', path: 'Core'
  cp_gem 'cocoapods-deintegrate', 'cocoapods-deintegrate'
  cp_gem 'cocoapods-downloader',  'cocoapods-downloader', path: 'cocoapods-downloader'
  cp_gem 'cocoapods-plugins',     'cocoapods-plugins'
  cp_gem 'cocoapods-search',      'cocoapods-search'
  cp_gem 'cocoapods-stats',       'cocoapods-stats'
  cp_gem 'cocoapods-trunk',       'cocoapods-trunk'
  cp_gem 'cocoapods-try',         'cocoapods-try'
  cp_gem 'molinillo',             'Molinillo', path: 'Molinillo'
  cp_gem 'nanaimo',               'Nanaimo'
  cp_gem 'xcodeproj',             'Xcodeproj', path: 'Xcodeproj'
  ...
end
```

1. 在Cocoapods目录下，执行`bundle install`
2. 进入CocoaPods/examples/AFNetworking\ Example，执行`bundle exec pod install`



### pod install的分析

#### pod  命令的入口

当输入`pod install`命令的时候，首先系统会调用这个`pod`命令，所有的命令都是在`/bin`目录下存放的脚本。

```
$ command which pod
/usr/local/bin/pod
```

打开这个入口脚本`pod`文件：

```ruby
#!/System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/bin/ruby
#
# This file was generated by RubyGems.
#
# The application 'cocoapods' is installed as part of a gem, and
# this file is here to facilitate running it.
#

require 'rubygems'

version = ">= 0.a"

str = ARGV.first
if str
  # \A代表输入开始的位置，\z代表输入的结束
  str = str.b[/\A_(.*)_\z/, 1]
  if str and Gem::Version.correct?(str)
    version = str
    # shift 拿出第一个元素并移除
    ARGV.shift
  end
end

if Gem.respond_to?(:activate_bin_path)
load Gem.activate_bin_path('cocoapods', 'pod', version)
else
gem "cocoapods", version
load Gem.bin_path("cocoapods", "pod", version)
end

```

入口中将命令的执行指向了Gem组件的Path中，这样就找到了Cocoapods的入口脚本，即在`cocoapods/bin`目录下的`pod`。

```ruby
require 'cocoapods'

if profile_filename = ENV['COCOAPODS_PROFILE']
  require 'ruby-prof'
  reporter =
    case (profile_extname = File.extname(profile_filename))
    when '.txt'
      RubyProf::FlatPrinterWithLineNumbers
    when '.html'
      RubyProf::GraphHtmlPrinter
    when '.callgrind'
      RubyProf::CallTreePrinter
    else
      raise "Unknown profiler format indicated by extension: #{profile_extname}"
    end
  File.open(profile_filename, 'w') do |io|
    reporter.new(RubyProf.profile { Pod::Command.run(ARGV) }).print(io)
  end
else
  Pod::Command.run(ARGV)
end
```

在最后部分，通过调用`Pod::Command.run(ARGV)`,实例化了一个`CLAide::Command`对象，用户输入的命令及参数进入CLAide解析阶段，这个是一个命令解析工具，每次命令的执行，其实是对应到具体class的`run`方法。  

执行`pod install`的类是`Install`，继承于`Command`， 根据Podfile.lock的版本安装项目依赖项：

```ruby
module Pod
  class Command
    class Install < Command
      include RepoUpdate
      include ProjectDirectory
      def self.options
        [
          ['--repo-update', 'Force running `pod repo update` before install'],
          ['--deployment', 'Disallow any changes to the Podfile or the Podfile.lock during installation'],
          ['--clean-install', 'Ignore the contents of the project cache and force a full pod installation. This only ' \
            'applies to projects that have enabled incremental installation'],
        ].concat(super).reject { |(name, _)| name == '--no-repo-update' }
      end

      def initialize(argv)
        super
        @deployment = argv.flag?('deployment', false)
        @clean_install = argv.flag?('clean-install', false)
      end

      def run
        verify_podfile_exists!
        installer = installer_for_config
        installer.repo_update = repo_update?(:default => false)
        installer.update = false
        installer.deployment = @deployment
        installer.clean_install = @clean_install
        installer.install!
      end
    end
  end
end
```

`Install`是继承于`Command`命令的，所以对应的命令为`pod install`。如下写了一个`Test`类继承于`Command`类，实现`run`方法。

```ruby
module Pod
  class Command
    class Test < Command
      def run
        puts "----Test running--"
      end
    end
  end
end
```

在命令行输入：

```
$ bundle exec pod test
----Test running--
```



#### pod install主流程分析

`installer.rb`中的`run`方法中会从config中取一个`installer`的实例，再执行`install`方法，`installer`还有一个`update`的属性，这个就是`pod install`和`pod update`最大的区别：`pod update`会忽略Podfile.lock文件，重新对依赖进行分析。

```ruby
module Pod
  class Command
    class Update < Command
      include RepoUpdate
      include ProjectDirectory

      def run
        verify_podfile_exists!

        installer = installer_for_config
        installer.repo_update = repo_update?(:default => true)
        installer.clean_install = @clean_install
        if @pods.any? || @excluded_pods.any? || @source_pods.any?
          verify_lockfile_exists!
          verify_pods_are_installed!
          verify_excluded_pods_are_installed!

          @pods += @source_pods.select { |pod| config.lockfile.pod_names.include?(pod) }
          @pods = config.lockfile.pod_names.dup if @pods.empty?
          @pods -= @excluded_pods

          installer.update = { :pods => @pods }
        else
          UI.puts 'Update all pods'.yellow
          installer.update = true
        end
        installer.install!
      end
    end
  end
end
```

##### 1.  installer_for_config

Podfile的解析是由[Core](https://github.com/CocoaPods/Core)这个模块来完成的。

```ruby
def installer_for_config
  Installer.new(config.sandbox, config.podfile, config.lockfile)
end
```

`installer_for_config`方法获取config中的podfile、lockfile等信息实例一个`installer`。

```ruby
def podfile
  @podfile ||= Podfile.from_file(podfile_path) if podfile_path
end
```

```ruby
def self.from_file(path)
  path = Pathname.new(path)
  unless path.exist?
    raise Informative, "No Podfile exists at path `#{path}`."
  end

  case path.extname
  when '', '.podfile', '.rb'
    Podfile.from_ruby(path)
  when '.yaml'
    Podfile.from_yaml(path)
  else
    raise Informative, "Unsupported Podfile format `#{path}`."
  end
end
```

在Cocoapods/lib/cocoapods/config.rb中取出一个`Podfile`类的实例。`from_file`这个方法会根据Podfile类型的不同而选择不同的调用路径。

```ruby
def self.from_ruby(path, contents = nil)
  contents ||= File.open(path, 'r:utf-8', &:read) 
  podfile = Podfile.new(path) do
    begin
      eval(contents, nil, path.to_s)
    rescue Exception => e
      message = "Invalid `#{path.basename}` file: #{e.message}"
      raise DSLError.new(message, path, e, contents)
    end
  end
  podfile
end
```

`a ||= b`是一个条件赋值运算符，当a是未被定义或者为`false`，则计算b的值并将结果赋值给a，如果a是并定义且值为`true`，那么b则不会被计算。

```ruby
module Pod
  class Podfile
    module DSL
      def install!(installation_method, options = {}) end
      def pod(name = nil, *requirements) end
      def podspec(options = nil) end
      def target(name, options = nil) end
      def script_phase(options) end
      def platform(name, target = nil) end
      def project(path, build_configurations = {}) end
      def link_with(*) end
      def use_modular_headers! end
      def use_frameworks!(option = true) end
      def source(source) end
      def pre_install(&block) end
      def post_install(&block) end
      ...
    end
  end
end
```

在Podfile这个类的顶部，导入`include Pod::Podfile::DSL` 这行代码，这个`DSL`模块中定义了Podfile中所有方法。当使用`eval`执行文件中的代码时，就会执行这个模块里的方法。

```ruby
def target(name, options = nil)
  if options
    raise Informative, "Unsupported options `#{options}` for " \
    "target `#{name}`."
  end

  parent = current_target_definition
  definition = TargetDefinition.new(name, parent)
  self.current_target_definition = definition
  yield if block_given?
ensure
  self.current_target_definition = parent
end
```

这个方法会创建一个`TargetDefinition`类的实例，然后将它赋值给当前环境`current_target_definition`，这样之后使用`pod`定义的依赖都会填充在当前的`TargetDefinition`。

```ruby
def pod(name = nil, *requirements)
	unless name
		raise StandardError, 'A dependency requires a name.'
	end

	current_target_definition.store_pod(name, *requirements)
end
```

pod 主要是指定target依赖项的名称和版本等，如以下方式：

- 指定版本号，其中`~> 0.1.2`表示版本等于` '>= 0.1.2' && '< 0.2.0'`，且在符合要求的情况下总是匹配最新的版本。
- `pod 'xx', :configuration => 'Debug'`
- `pod 'xx', :subspecs => ['xx', 'xx']`
- `pod 'xx', :path => '~/xx'`
- `pod 'xx', :git => 'xx', :branch => 'dev'` 或者`:tag => ''`、`:commit => ''`

当`pod`方法被调用时，会执行target_definition.rb中的`store_pod`方法，将依赖储存到当前的`target`的`dependencies`数组中：

```ruby
def store_pod(name, *requirements)
  return if parse_subspecs(name, requirements) # This parse method must be called first
  parse_inhibit_warnings(name, requirements)
  parse_modular_headers(name, requirements)
  parse_configuration_whitelist(name, requirements)
  parse_project_name(name, requirements)

  if requirements && !requirements.empty?
    pod = { name => requirements }
  else
    pod = name
  end

  get_hash_value('dependencies', []) << pod
  nil
end

```

总结：Cocoapods对Podfile的解析简单概括就是构建了一个包含一些方法的上下文`DSL`，然后直接执行`eval`方法将文件的内容当做代码来执行，并将相应解析出来的数据储存到具体的类中。



在`installer`实例组装完成后，调用其`installer.install!`方法，进入`pod install`命令执行的主体部分。

```ruby
def install!
  # 检测是否在Pods内部，如果不是则做一些install前准备工作
  prepare
  # 依赖图的解析
  resolve_dependencies
  # 依赖下载
  download_dependencies
  # 检验之前流程中的产物Pod所生成的Targets的合法性
  validate_targets
  if installation_options.skip_pods_project_generation?
    show_skip_pods_project_generation_message
  else
    integrate
  end
  write_lockfiles
  # 执行任何install 后的操作， 例如一些plugin 可以插入在这里
  perform_post_install_actions
end
```



##### 2. prepare

`prepare`方法的实现如下：

```ruby
def prepare
  # Raise if pwd is inside Pods
  # 检测当前目录是项目根目录，直接抛出错误
  if Dir.pwd.start_with?(sandbox.root.to_path)
    message = 'Command should be run from a directory outside Pods directory.'
    message << "\n\n\tCurrent directory is #{UI.path(Pathname.pwd)}\n"
    raise Informative, message
  end
  UI.message 'Preparing' do
    # 如果lock文件的Cocoapods版本和当前的版本不同，需要使用新版本依赖的xcodeproj对工程文件进行更新
    deintegrate_if_different_major_version
    # 对sandbox（Pods）目录建立子目录结构
    sandbox.prepare
    # 检测PluginManager 是否有pre-install的plugin
    ensure_plugins_are_installed!
    # 执行插件中的pre-install的所有hooks方法
    run_plugins_pre_install_hooks
  end
end
```

在`prepare`阶段会将`pod install`的准备工作完成，包括版本一致性、Pods目录结构创建以及`pre-install`相关的plugins 脚本执行。



##### 3. 依赖分析

```ruby
def resolve_dependencies
  plugin_sources = run_source_provider_hooks
  # Analyzer 是通过分析Podfile、Podfile.lock，沙盒中的manifest，从而生成了一张依赖关系表
  analyzer = create_analyzer(plugin_sources)

  UI.section 'Updating local specs repositories' do
    analyzer.update_repositories
  end if repo_update? #pod install --repo-update

  UI.section 'Analyzing dependencies' do
    # 从analyzer取出最新的分析结果
    analyze(analyzer)

    # 调试使用~
    @analysis_result.podfile_dependency_cache.podfile_dependencies.each { |item| 
      p item
    }

    p "------analysis_result-------"
    p @analysis_result.podfile_state
    p @analysis_result.sandbox_state
    
    # Sepicat工程中各个target对应的spec情况
    @analysis_result.specs_by_target.keys.each do |item|
      puts "----#{item}----"
      @analysis_result.specs_by_target[item].each do |sub_item| #specs_by_target查看各个target相关的specs
        p sub_item
      end
    end


    # 校验pod白名单的configuration的有效性 如拼写错误降级识别，白名单过滤
    validate_build_configurations
  end

  # pod install --deployment
  # 禁止在install 过程中变更 Podfile/Podfile.lock
  UI.section 'Verifying no changes' do
    verify_no_podfile_changes!
    verify_no_lockfile_changes!
  end if deployment?

  analyzer
end
```

依赖解析过程会通过`Podfile`、`Podfild.lock`、`manifest`文件来生成一个`Analyzer`对象，在`Analyzer`内部会使用**Molinillo**。

```ruby
def analyze(analyzer = create_analyzer)
  @analysis_result = analyzer.analyze
  @aggregate_targets = @analysis_result.targets
  @pod_targets = @analysis_result.pod_targets
end
```

`analyzer.analyze`会调用`resolve_dependencies`方法，最终会调用`Resolver`的`resolve`方法：

```ruby
def resolve
  dependencies = @podfile_dependency_cache.target_definition_list.flat_map do |target|
    @podfile_dependency_cache.target_definition_dependencies(target).each do |dep|
      next unless target.platform
      @platforms_by_dependency[dep].push(target.platform)
    end
  end.uniq
  @platforms_by_dependency.each_value(&:uniq!)
  @activated = Molinillo::Resolver.new(self, self).resolve(dependencies, locked_dependencies)
  resolver_specs_by_target
rescue Molinillo::ResolverError => e
  handle_resolver_error(e)
end
```

这里的`Molinillo::Resolver`就是用于解决依赖关系的类。 `Milinillo`算法的核心是回溯(Backtracking)、向前检查(forward check)，整个过程会追踪栈中的两个状态（依赖和可能性）。

Resolver的大概过程如下：

![](https://raw.githubusercontent.com/liututu1213/imageForSource/master/CocoaPods/Resolver.png)

下面是调试输出的日志：

`podfile_dependency_cache.podfile_dependencies`:

```
<Pod::Dependency name=AFNetworking requirements== 1.3.3 source=nil external_source=nil>
<Pod::Dependency name=SDWebImage requirements=>= 0 source=nil external_source=nil>
<Pod::Dependency name=Moya requirements=>= 0 source=nil external_source=nil>
<Pod::Dependency name=SnapKit requirements=>= 0 source=nil external_source=nil>
```

`@analysis_result.podfile_state`和 `@analysis_result.sandbox_state`分别的输出是：

```
#<Pod::Installer::Analyzer::SpecsState:0x00007ff58bbb5fc0 @added=#<Set: {}>, @deleted=#<Set: {}>, @changed=#<Set: {}>, @unchanged=#<Set: {"AFNetworking", "Moya", "SDWebImage", "SnapKit"}>>
#<Pod::Installer::Analyzer::SpecsState:0x00007ff58bbec980 @added=#<Set: {}>, @deleted=#<Set: {}>, @changed=#<Set: {}>, @unchanged=#<Set: {"AFNetworking", "Alamofire", "Moya", "Result", "SDWebImage", "SnapKit"}>>
```

`analysis_result.specs_by_target`查看各个target相关的specs

```
----Pods-AFNetworking Example----
#<Pod::Specification name="AFNetworking">
----Pods-AFNetworking iOS Example----
#<Pod::Specification name="AFNetworking">
#<Pod::Specification name="Alamofire">
#<Pod::Specification name="Moya">
#<Pod::Specification name="Moya/Core">
#<Pod::Specification name="Result">
#<Pod::Specification name="SDWebImage">
#<Pod::Specification name="SDWebImage/Core">
#<Pod::Specification name="SnapKit">
```



#####  4. 依赖下载

```ruby
def download_dependencies
  UI.section 'Downloading dependencies' do
    # 构造Pod Source Installer
    install_pod_sources
    # 执行pre install 的hooks
    run_podfile_pre_install_hooks
    clean_pod_sources
  end
end
```

下面是`install_pod_sources`方法的实现：

```ruby
def install_pod_sources
  @installed_specs = []
  # install的Pod只需要两种状态：added和changed状态的并集
  pods_to_install = sandbox_state.added | sandbox_state.changed
  title_options = { :verbose_prefix => '-> '.green }


  # 将Podfile解析后排序处理
  root_specs.sort_by(&:name).each do |spec|
    # 如果Pod是added或者changed状态
    if pods_to_install.include?(spec.name)
      # 如果是changed状态并且是manifest 已经有记录
      if sandbox_state.changed.include?(spec.name) && sandbox.manifest
        # 版本更新
        current_version = spec.version
        # 被更新版本记录
        previous_version = sandbox.manifest.version(spec.name)
        # 变动记录
        has_changed_version = current_version != previous_version
        # 找到第一个包含spec.name的Pod，获取对应的Repo
        current_repo = analysis_result.specs_by_source.detect { |key, values| break key if values.map(&:name).include?(spec.name) }
        # 获取当前的仓库
        current_repo &&= current_repo.url || current_repo.name
        # 是否仓库有变动
        previous_spec_repo = sandbox.manifest.spec_repo(spec.name)
        has_changed_repo = !previous_spec_repo.nil? && current_repo && !current_repo.casecmp(previous_spec_repo).zero?
        title = "Installing #{spec.name} #{spec.version}"
        title << " (was #{previous_version} and source changed to `#{current_repo}` from `#{previous_spec_repo}`)" if has_changed_version && has_changed_repo
        title << " (was #{previous_version})" if has_changed_version && !has_changed_repo
        title << " (source changed to `#{current_repo}` from `#{previous_spec_repo}`)" if !has_changed_version && has_changed_repo
      else
        # 非changed状态
        title = "Installing #{spec}"
      end
      UI.titled_section(title.green, title_options) do
        # 通过name拿到对应的installer，记录到@pod_installer中
        install_source_of_pod(spec.name)
      end
    else
      #如果没有changed情况,则创建一个PodSourceInstaller实例
      UI.section("Using #{spec}".red, title_options[:verbose_prefix]) do
        create_pod_installer(spec.name)
      end
    end
  end
end
```

这个方法主要是根据依赖分析的结果，根据Pod的状态的不同进行不同的处理，如果在`pods_to_install`里面则安装Pod`install_source_of_pod`，否则直接走`create_pod_installer`方法，直接从缓存中取。

```ruby
# 通过缓存返回PodSourceInstaller实例
def create_pod_installer(pod_name)
  specs_by_platform = specs_for_pod(pod_name)

  if specs_by_platform.empty?
    requiring_targets = pod_targets.select { |pt| pt.recursive_dependent_targets.any? { |dt| dt.pod_name == pod_name } }
    message = "Could not install '#{pod_name}' pod"
    message += ", dependended upon by #{requiring_targets.to_sentence}" unless requiring_targets.empty?
    message += '. There is either no platform to build for, or no target to build.'
    raise StandardError, message
  end

  # 通过sandbox，specs的platform信息生成Installer实例
  pod_installer = PodSourceInstaller.new(sandbox, podfile, specs_by_platform, :can_cache => installation_options.clean?)
  pod_installers << pod_installer
  pod_installer
end

# 安装Pods,如果resolver声明一个Pod已经安装或者已经存在则将其删除并重新安装
# 如果不存在则直接安装
def install_source_of_pod(pod_name)
  pod_installer = create_pod_installer(pod_name)
  pod_installer.install!
  @installed_specs.concat(pod_installer.specs_by_platform.values.flatten.uniq)
end
```

`pod_installer`会调用`install!`方法(pod_source_installer.rb)：

```ruby
def install!
  # 如果未经历过pre-download阶段或者local阶段的Pod，则通过对应的Source下载
  download_source unless predownloaded? || local?
  # 执行Spec 中的Prepar Command
  PodSourcePreparer.new(root_spec, root).prepare! if local?
  sandbox.remove_local_podspec(name) unless predownloaded? || local? || external?
end

def download_source
  verify_source_is_secure(root_spec)
  download_result = Downloader.download(download_request, root, :can_cache => can_cache?)

  if (specific_source = download_result.checkout_options) && specific_source != root_spec.source
    sandbox.store_checkout_source(root_spec.name, specific_source)
  end
end
```

上面的方法主要是将Pod通过对应的source下载下来，会去调用`Downloader`组件处理所有的下载的逻辑

#####  5. targets 校验

`validate_targets`过程是用来验证之前流程中的产物Pod所生成的targets的合法性方法。

```ruby
def validate_targets
  validator = Xcode::TargetValidator.new(aggregate_targets, pod_targets, installation_options)
  validator.validate!
end

# target_validator.rb
def validate!
  # 重名检测
  verify_no_duplicate_framework_and_library_names
  # 用来验证动态库是否有静态库或者framework静态库
  verify_no_static_framework_transitive_dependencies
  # 验证Pod中是否指明多个Swift版本，如果有的话需要检测这些依赖是否需要进行build
  verify_swift_pods_swift_version
  # 验证Swift 的Pod是否有module依赖
  verify_swift_pods_have_module_dependencies
  verify_no_multiple_project_names if installation_options.generate_multiple_pod_projects?
end
```

`verify_no_static_framework_transitive_dependencies`这个方法是用来验证动态库中是否有.a或.framework的静态库，场景：A组件依赖B组件，B组件中通过`vendored_libraries`方式加载的静态库(.a、.framework)，如果此时在Podfile里面使用了`use_framework!`,在打包的时候`framework`会将`vendored_libraries`中的内容包括进来，这个时候就在符号决议的时候产生冲突，在混合开发的项目里面，动态库中依赖静态库的场景还是很常见的，可以查看这篇组件化的文章：[组件化-动态库实战](https://www.valiantcat.cn/index.php/2017/04/24/45.html)。

```
The 'Pods-xx' target has transitive dependencies that include static binaries: (static_libs.to_sentence)

```

在swift项目中，必须使用`use_framework!`（目前Cocoapods1.5宣布已经支持Swift使用静态库），因此经常会遇到上述的问题。  

除了文章中这种处理方式，还可以通过修改cocoapods相关的参数达到目的：  

1.修改pod库中的`podspec`，增加`pod_target_xcconfig`(表示pod本身被依赖时，修改的编译选项，而user_target_xcconfig表示修改依赖pod的项目的编译选项)

```ruby
s.pod_target_xcconfig = {
    'FRAMEWORK_SEARCH_PATHS' => '$(inherited) $(PODS_ROOT)/AlipaySDKIniOS',
    'OTHER_LDFLAGS'          => '$(inherited) -undefined dynamic_lookup'
}
```



2.hook	`verify_no_static_framework_transitive_dependencies`方法，不对动态库依赖静态做检测

```ruby
pre_install do |installer|
    # workaround for https://github.com/CocoaPods/CocoaPods/issues/3289
    def installer.verify_no_static_framework_transitive_dependencies; end
end
```

特别说明下`vendored_libraries`是用来在`podspec`中指定依赖的静态库.a或.framework，如``s.vendored_libraries = 'libWeiboSDK/libWeiboSDK.a'`。





##### 6. 集成

 `generate_pods_project`会把所有的组件通过Project文件的形式组织起啦，并且对Project做一些用户指定的配置。

```ruby
def integrate
  # 生成外层项目
  generate_pods_project
  if installation_options.integrate_targets?
    # 集成用户配置，读取依赖项，使用xcconfig来配置
    integrate_user_project
  else
    UI.section 'Skipping User Project Integration'
  end
end

def generate_pods_project
  stage_sandbox(sandbox, pod_targets)

  cache_analysis_result = analyze_project_cache
  pod_targets_to_generate = cache_analysis_result.pod_targets_to_generate
  aggregate_targets_to_generate = cache_analysis_result.aggregate_targets_to_generate

  clean_sandbox(pod_targets_to_generate)

  # 
  create_and_save_projects(pod_targets_to_generate, aggregate_targets_to_generate,
                           cache_analysis_result.build_configurations, cache_analysis_result.project_object_version)
  SandboxDirCleaner.new(sandbox, pod_targets, aggregate_targets).clean!

  update_project_cache(cache_analysis_result, target_installation_results)
end

def integrate_user_project
  UI.section "Integrating client #{'project'.pluralize(aggregate_targets.map(&:user_project_path).uniq.count)}" do

    installation_root = config.installation_root
    integrator = UserProjectIntegrator.new(podfile, sandbox, installation_root, aggregate_targets, generated_aggregate_targets,
                                           :use_input_output_paths => !installation_options.disable_input_output_paths?)
    integrator.integrate!
  end
end
```

在`~/lib/cocoapods/installer/user_project_integrator.rb`文件中的`integrate`方法：

```ruby
def integrate!
  create_workspace
  deintegrated_projects = deintegrate_removed_targets
  integrate_user_targets
  warn_about_xcconfig_overrides
  projects_to_save = (user_projects_to_integrate + deintegrated_projects).uniq
  save_projects(projects_to_save)
end
```



###  pod install vs pod update

在[cocoapods guides](https://guides.cocoapods.org/using/pod-install-vs-update.html) 中对于`pod install` vs `pod update`区别的翻译如下：

1.在项目中第一次使用Cocoapods时（即没有`Podfile.lock`文件的情况），或者在podfile中添加、删除、更新pods时，可使用`pod install`下载安装pod。

2.`pod update [PODNAME]`用在需要更新pods的最新版本时

#### pod install

除了在新建工程时，需用到`pod install`，在后续执行`pod install`时，对于已经列在`podfile.lock`中的pod，它会下载lock锁定的版本，而不会去检查是否有最新的可用版本，对于没有在podfile.lock中文件的库，会根据podfile文件中指定的版本去下载符合指定返回内最新的版本。

##### pod update

```ruby
# update.rb
installer.repo_update = repo_update?(:default => true)
installer.update = false

# analyzer.rb
deleted_and_changed += pods_to_update[:pods] if update_mode == :selected
```

`pod update [PODNAME]`命令，首先会更新本地的spec 仓库，`pod install`默认的`repo_update`为`false`。其次会忽略podfile.lock中的锁定的版本，更新到podfile中指定的版本。



