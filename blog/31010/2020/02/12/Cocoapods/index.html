<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Cocoapods是开发OSX和iOS应用程序的一个第三方库的依赖管理工具，只用这个工具可以简化对组件依赖。更新过程。Cocoapods是用Ruby写的，由若干个gems组成：相关的源码。  CocoaPods&#x2F;Specs 这是保存第三方组件podspec文件的仓库，包含了每一个第三方组件所有版本的podsepc文件。  CocoaPods&#x2F;CocoaPods 一个面向用户的组件，每当执行pod">
<meta property="og:type" content="article">
<meta property="og:title" content="Cocoapods源码分析">
<meta property="og:url" content="https://github.com/liututu1213/liututu1213.github.io/blog/31010/2020/02/12/Cocoapods/index.html">
<meta property="og:site_name" content="渣渣程序员">
<meta property="og:description" content="Cocoapods是开发OSX和iOS应用程序的一个第三方库的依赖管理工具，只用这个工具可以简化对组件依赖。更新过程。Cocoapods是用Ruby写的，由若干个gems组成：相关的源码。  CocoaPods&#x2F;Specs 这是保存第三方组件podspec文件的仓库，包含了每一个第三方组件所有版本的podsepc文件。  CocoaPods&#x2F;CocoaPods 一个面向用户的组件，每当执行pod">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/liututu1213/imageForSource/master/CocoaPods/Resolver.png">
<meta property="article:published_time" content="2020-02-11T16:57:24.000Z">
<meta property="article:modified_time" content="2020-05-25T14:30:30.051Z">
<meta property="article:author" content="liututu1213">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/liututu1213/imageForSource/master/CocoaPods/Resolver.png">

<link rel="canonical" href="https://github.com/liututu1213/liututu1213.github.io/blog/31010/2020/02/12/Cocoapods/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Cocoapods源码分析 | 渣渣程序员</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="渣渣程序员" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">渣渣程序员</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/liututu1213/liututu1213.github.io/blog/31010/2020/02/12/Cocoapods/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liututu1213">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渣渣程序员">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Cocoapods源码分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-12 00:57:24" itemprop="dateCreated datePublished" datetime="2020-02-12T00:57:24+08:00">2020-02-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-25 22:30:30" itemprop="dateModified" datetime="2020-05-25T22:30:30+08:00">2020-05-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ruby/" itemprop="url" rel="index"><span itemprop="name">Ruby</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Cocoapods是开发OSX和iOS应用程序的一个第三方库的依赖管理工具，只用这个工具可以简化对组件依赖。更新过程。Cocoapods是用Ruby写的，由若干个gems组成：相关的<a href="https://github.com/CocoaPods">源码</a>。</p>
<ul>
<li><p><strong><a href="https://github.com/CocoaPods/Specs">CocoaPods/Specs</a></strong></p>
<p>这是保存第三方组件podspec文件的仓库，包含了每一个第三方组件所有版本的podsepc文件。</p>
</li>
<li><p><strong><a href="https://github.com/CocoaPods/CocoaPods">CocoaPods/CocoaPods</a></strong></p>
<p>一个面向用户的组件，每当执行<code>pod install</code>等命令时，都会调用这个组价。</p>
</li>
<li><p><strong><a href="https://github.com/CocoaPods/Core">CocoaPods/Core</a></strong></p>
<p>提供支持与Cocoapods相关文件的处理</p>
</li>
<li><p><strong><a href="https://github.com/CocoaPods/Xcodeproj">CocoaPods/Xcodeproj</a></strong></p>
<p>这个gem组件是用来创建和修改Xcode projects，负责所有工程文件的整合。</p>
</li>
<li><p><a href="https://www.rubydoc.info/gems/cocoapods-downloader" target="_blank" rel="noopener">CocoaPods Downloader</a>: 下载器</p>
</li>
<li><p><a href="https://www.rubydoc.info/gems/claide" target="_blank" rel="noopener">CLAide</a>: 命令行参数解析器</p>
</li>
<li><p><a href="https://github.com/CocoaPods/Molinillo">Molinillo</a> 依赖分析</p>
</li>
</ul>
<p>在Cocoapods中，所有的命令都会由<code>Commad</code>派发到对应的类。</p>
<h3 id="Debug-Cocoapods"><a href="#Debug-Cocoapods" class="headerlink" title="Debug Cocoapods"></a>Debug Cocoapods</h3><p>把Cocoapods相关的代码clone下来，Cocoapods项目作为入口，修改Cocoapods/Gemfile，指定每个依赖的path:</p>
<pre><code class="ruby"># 声明Cocoapods对于git 仓库的依赖关系
# 兼容本地git 仓库模式开发
def cp_gem(name, repo_name, branch = &#39;master&#39;, path: false)
  return gem name if SKIP_UNRELEASED_VERSIONS
  # 如果path参数为true，则将在&quot;.../[repo_name]&quot;这个路径下搜索仓库
  opts = if path
           { :path =&gt; &quot;../#{repo_name}&quot; }
         else
           url = &quot;https://github.com/CocoaPods/#{repo_name}.git&quot;
           { :git =&gt; url, :branch =&gt; branch }
         end
  # 返回标准的Gemfile Gem 导入格式
  gem name, opts
end

source &#39;https://rubygems.org&#39;

gemspec

gem &#39;json&#39;, :git =&gt; &#39;https://github.com/segiddins/json.git&#39;, :branch =&gt; &#39;seg-1.7.7-ruby-2.2&#39;

group :development do
  cp_gem &#39;claide&#39;,                &#39;CLAide&#39;, path: &#39;CLAide&#39;
  cp_gem &#39;cocoapods-core&#39;,        &#39;Core&#39;, path: &#39;Core&#39;
  cp_gem &#39;cocoapods-deintegrate&#39;, &#39;cocoapods-deintegrate&#39;
  cp_gem &#39;cocoapods-downloader&#39;,  &#39;cocoapods-downloader&#39;, path: &#39;cocoapods-downloader&#39;
  cp_gem &#39;cocoapods-plugins&#39;,     &#39;cocoapods-plugins&#39;
  cp_gem &#39;cocoapods-search&#39;,      &#39;cocoapods-search&#39;
  cp_gem &#39;cocoapods-stats&#39;,       &#39;cocoapods-stats&#39;
  cp_gem &#39;cocoapods-trunk&#39;,       &#39;cocoapods-trunk&#39;
  cp_gem &#39;cocoapods-try&#39;,         &#39;cocoapods-try&#39;
  cp_gem &#39;molinillo&#39;,             &#39;Molinillo&#39;, path: &#39;Molinillo&#39;
  cp_gem &#39;nanaimo&#39;,               &#39;Nanaimo&#39;
  cp_gem &#39;xcodeproj&#39;,             &#39;Xcodeproj&#39;, path: &#39;Xcodeproj&#39;
  ...
end</code></pre>
<ol>
<li>在Cocoapods目录下，执行<code>bundle install</code></li>
<li>进入CocoaPods/examples/AFNetworking\ Example，执行<code>bundle exec pod install</code></li>
</ol>
<h3 id="pod-install的分析"><a href="#pod-install的分析" class="headerlink" title="pod install的分析"></a>pod install的分析</h3><h4 id="pod-命令的入口"><a href="#pod-命令的入口" class="headerlink" title="pod  命令的入口"></a>pod  命令的入口</h4><p>当输入<code>pod install</code>命令的时候，首先系统会调用这个<code>pod</code>命令，所有的命令都是在<code>/bin</code>目录下存放的脚本。</p>
<pre><code>$ command which pod
/usr/local/bin/pod</code></pre><p>打开这个入口脚本<code>pod</code>文件：</p>
<pre><code class="ruby">#!/System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/bin/ruby
#
# This file was generated by RubyGems.
#
# The application &#39;cocoapods&#39; is installed as part of a gem, and
# this file is here to facilitate running it.
#

require &#39;rubygems&#39;

version = &quot;&gt;= 0.a&quot;

str = ARGV.first
if str
  # \A代表输入开始的位置，\z代表输入的结束
  str = str.b[/\A_(.*)_\z/, 1]
  if str and Gem::Version.correct?(str)
    version = str
    # shift 拿出第一个元素并移除
    ARGV.shift
  end
end

if Gem.respond_to?(:activate_bin_path)
load Gem.activate_bin_path(&#39;cocoapods&#39;, &#39;pod&#39;, version)
else
gem &quot;cocoapods&quot;, version
load Gem.bin_path(&quot;cocoapods&quot;, &quot;pod&quot;, version)
end
</code></pre>
<p>入口中将命令的执行指向了Gem组件的Path中，这样就找到了Cocoapods的入口脚本，即在<code>cocoapods/bin</code>目录下的<code>pod</code>。</p>
<pre><code class="ruby">require &#39;cocoapods&#39;

if profile_filename = ENV[&#39;COCOAPODS_PROFILE&#39;]
  require &#39;ruby-prof&#39;
  reporter =
    case (profile_extname = File.extname(profile_filename))
    when &#39;.txt&#39;
      RubyProf::FlatPrinterWithLineNumbers
    when &#39;.html&#39;
      RubyProf::GraphHtmlPrinter
    when &#39;.callgrind&#39;
      RubyProf::CallTreePrinter
    else
      raise &quot;Unknown profiler format indicated by extension: #{profile_extname}&quot;
    end
  File.open(profile_filename, &#39;w&#39;) do |io|
    reporter.new(RubyProf.profile { Pod::Command.run(ARGV) }).print(io)
  end
else
  Pod::Command.run(ARGV)
end</code></pre>
<p>在最后部分，通过调用<code>Pod::Command.run(ARGV)</code>,实例化了一个<code>CLAide::Command</code>对象，用户输入的命令及参数进入CLAide解析阶段，这个是一个命令解析工具，每次命令的执行，其实是对应到具体class的<code>run</code>方法。  </p>
<p>执行<code>pod install</code>的类是<code>Install</code>，继承于<code>Command</code>， 根据Podfile.lock的版本安装项目依赖项：</p>
<pre><code class="ruby">module Pod
  class Command
    class Install &lt; Command
      include RepoUpdate
      include ProjectDirectory
      def self.options
        [
          [&#39;--repo-update&#39;, &#39;Force running `pod repo update` before install&#39;],
          [&#39;--deployment&#39;, &#39;Disallow any changes to the Podfile or the Podfile.lock during installation&#39;],
          [&#39;--clean-install&#39;, &#39;Ignore the contents of the project cache and force a full pod installation. This only &#39; \
            &#39;applies to projects that have enabled incremental installation&#39;],
        ].concat(super).reject { |(name, _)| name == &#39;--no-repo-update&#39; }
      end

      def initialize(argv)
        super
        @deployment = argv.flag?(&#39;deployment&#39;, false)
        @clean_install = argv.flag?(&#39;clean-install&#39;, false)
      end

      def run
        verify_podfile_exists!
        installer = installer_for_config
        installer.repo_update = repo_update?(:default =&gt; false)
        installer.update = false
        installer.deployment = @deployment
        installer.clean_install = @clean_install
        installer.install!
      end
    end
  end
end</code></pre>
<p><code>Install</code>是继承于<code>Command</code>命令的，所以对应的命令为<code>pod install</code>。如下写了一个<code>Test</code>类继承于<code>Command</code>类，实现<code>run</code>方法。</p>
<pre><code class="ruby">module Pod
  class Command
    class Test &lt; Command
      def run
        puts &quot;----Test running--&quot;
      end
    end
  end
end</code></pre>
<p>在命令行输入：</p>
<pre><code>$ bundle exec pod test
----Test running--</code></pre><h4 id="pod-install主流程分析"><a href="#pod-install主流程分析" class="headerlink" title="pod install主流程分析"></a>pod install主流程分析</h4><p><code>installer.rb</code>中的<code>run</code>方法中会从config中取一个<code>installer</code>的实例，再执行<code>install</code>方法，<code>installer</code>还有一个<code>update</code>的属性，这个就是<code>pod install</code>和<code>pod update</code>最大的区别：<code>pod update</code>会忽略Podfile.lock文件，重新对依赖进行分析。</p>
<pre><code class="ruby">module Pod
  class Command
    class Update &lt; Command
      include RepoUpdate
      include ProjectDirectory

      def run
        verify_podfile_exists!

        installer = installer_for_config
        installer.repo_update = repo_update?(:default =&gt; true)
        installer.clean_install = @clean_install
        if @pods.any? || @excluded_pods.any? || @source_pods.any?
          verify_lockfile_exists!
          verify_pods_are_installed!
          verify_excluded_pods_are_installed!

          @pods += @source_pods.select { |pod| config.lockfile.pod_names.include?(pod) }
          @pods = config.lockfile.pod_names.dup if @pods.empty?
          @pods -= @excluded_pods

          installer.update = { :pods =&gt; @pods }
        else
          UI.puts &#39;Update all pods&#39;.yellow
          installer.update = true
        end
        installer.install!
      end
    end
  end
end</code></pre>
<h5 id="1-installer-for-config"><a href="#1-installer-for-config" class="headerlink" title="1.  installer_for_config"></a>1.  installer_for_config</h5><p>Podfile的解析是由<a href="https://github.com/CocoaPods/Core">Core</a>这个模块来完成的。</p>
<pre><code class="ruby">def installer_for_config
  Installer.new(config.sandbox, config.podfile, config.lockfile)
end</code></pre>
<p><code>installer_for_config</code>方法获取config中的podfile、lockfile等信息实例一个<code>installer</code>。</p>
<pre><code class="ruby">def podfile
  @podfile ||= Podfile.from_file(podfile_path) if podfile_path
end</code></pre>
<pre><code class="ruby">def self.from_file(path)
  path = Pathname.new(path)
  unless path.exist?
    raise Informative, &quot;No Podfile exists at path `#{path}`.&quot;
  end

  case path.extname
  when &#39;&#39;, &#39;.podfile&#39;, &#39;.rb&#39;
    Podfile.from_ruby(path)
  when &#39;.yaml&#39;
    Podfile.from_yaml(path)
  else
    raise Informative, &quot;Unsupported Podfile format `#{path}`.&quot;
  end
end</code></pre>
<p>在Cocoapods/lib/cocoapods/config.rb中取出一个<code>Podfile</code>类的实例。<code>from_file</code>这个方法会根据Podfile类型的不同而选择不同的调用路径。</p>
<pre><code class="ruby">def self.from_ruby(path, contents = nil)
  contents ||= File.open(path, &#39;r:utf-8&#39;, &amp;:read) 
  podfile = Podfile.new(path) do
    begin
      eval(contents, nil, path.to_s)
    rescue Exception =&gt; e
      message = &quot;Invalid `#{path.basename}` file: #{e.message}&quot;
      raise DSLError.new(message, path, e, contents)
    end
  end
  podfile
end</code></pre>
<p><code>a ||= b</code>是一个条件赋值运算符，当a是未被定义或者为<code>false</code>，则计算b的值并将结果赋值给a，如果a是并定义且值为<code>true</code>，那么b则不会被计算。</p>
<pre><code class="ruby">module Pod
  class Podfile
    module DSL
      def install!(installation_method, options = {}) end
      def pod(name = nil, *requirements) end
      def podspec(options = nil) end
      def target(name, options = nil) end
      def script_phase(options) end
      def platform(name, target = nil) end
      def project(path, build_configurations = {}) end
      def link_with(*) end
      def use_modular_headers! end
      def use_frameworks!(option = true) end
      def source(source) end
      def pre_install(&amp;block) end
      def post_install(&amp;block) end
      ...
    end
  end
end</code></pre>
<p>在Podfile这个类的顶部，导入<code>include Pod::Podfile::DSL</code> 这行代码，这个<code>DSL</code>模块中定义了Podfile中所有方法。当使用<code>eval</code>执行文件中的代码时，就会执行这个模块里的方法。</p>
<pre><code class="ruby">def target(name, options = nil)
  if options
    raise Informative, &quot;Unsupported options `#{options}` for &quot; \
    &quot;target `#{name}`.&quot;
  end

  parent = current_target_definition
  definition = TargetDefinition.new(name, parent)
  self.current_target_definition = definition
  yield if block_given?
ensure
  self.current_target_definition = parent
end</code></pre>
<p>这个方法会创建一个<code>TargetDefinition</code>类的实例，然后将它赋值给当前环境<code>current_target_definition</code>，这样之后使用<code>pod</code>定义的依赖都会填充在当前的<code>TargetDefinition</code>。</p>
<pre><code class="ruby">def pod(name = nil, *requirements)
    unless name
        raise StandardError, &#39;A dependency requires a name.&#39;
    end

    current_target_definition.store_pod(name, *requirements)
end</code></pre>
<p>pod 主要是指定target依赖项的名称和版本等，如以下方式：</p>
<ul>
<li>指定版本号，其中<code>~&gt; 0.1.2</code>表示版本等于<code>&#39;&gt;= 0.1.2&#39; &amp;&amp; &#39;&lt; 0.2.0&#39;</code>，且在符合要求的情况下总是匹配最新的版本。</li>
<li><code>pod &#39;xx&#39;, :configuration =&gt; &#39;Debug&#39;</code></li>
<li><code>pod &#39;xx&#39;, :subspecs =&gt; [&#39;xx&#39;, &#39;xx&#39;]</code></li>
<li><code>pod &#39;xx&#39;, :path =&gt; &#39;~/xx&#39;</code></li>
<li><code>pod &#39;xx&#39;, :git =&gt; &#39;xx&#39;, :branch =&gt; &#39;dev&#39;</code> 或者<code>:tag =&gt; &#39;&#39;</code>、<code>:commit =&gt; &#39;&#39;</code></li>
</ul>
<p>当<code>pod</code>方法被调用时，会执行target_definition.rb中的<code>store_pod</code>方法，将依赖储存到当前的<code>target</code>的<code>dependencies</code>数组中：</p>
<pre><code class="ruby">def store_pod(name, *requirements)
  return if parse_subspecs(name, requirements) # This parse method must be called first
  parse_inhibit_warnings(name, requirements)
  parse_modular_headers(name, requirements)
  parse_configuration_whitelist(name, requirements)
  parse_project_name(name, requirements)

  if requirements &amp;&amp; !requirements.empty?
    pod = { name =&gt; requirements }
  else
    pod = name
  end

  get_hash_value(&#39;dependencies&#39;, []) &lt;&lt; pod
  nil
end
</code></pre>
<p>总结：Cocoapods对Podfile的解析简单概括就是构建了一个包含一些方法的上下文<code>DSL</code>，然后直接执行<code>eval</code>方法将文件的内容当做代码来执行，并将相应解析出来的数据储存到具体的类中。</p>
<p>在<code>installer</code>实例组装完成后，调用其<code>installer.install!</code>方法，进入<code>pod install</code>命令执行的主体部分。</p>
<pre><code class="ruby">def install!
  # 检测是否在Pods内部，如果不是则做一些install前准备工作
  prepare
  # 依赖图的解析
  resolve_dependencies
  # 依赖下载
  download_dependencies
  # 检验之前流程中的产物Pod所生成的Targets的合法性
  validate_targets
  if installation_options.skip_pods_project_generation?
    show_skip_pods_project_generation_message
  else
    integrate
  end
  write_lockfiles
  # 执行任何install 后的操作， 例如一些plugin 可以插入在这里
  perform_post_install_actions
end</code></pre>
<h5 id="2-prepare"><a href="#2-prepare" class="headerlink" title="2. prepare"></a>2. prepare</h5><p><code>prepare</code>方法的实现如下：</p>
<pre><code class="ruby">def prepare
  # Raise if pwd is inside Pods
  # 检测当前目录是项目根目录，直接抛出错误
  if Dir.pwd.start_with?(sandbox.root.to_path)
    message = &#39;Command should be run from a directory outside Pods directory.&#39;
    message &lt;&lt; &quot;\n\n\tCurrent directory is #{UI.path(Pathname.pwd)}\n&quot;
    raise Informative, message
  end
  UI.message &#39;Preparing&#39; do
    # 如果lock文件的Cocoapods版本和当前的版本不同，需要使用新版本依赖的xcodeproj对工程文件进行更新
    deintegrate_if_different_major_version
    # 对sandbox（Pods）目录建立子目录结构
    sandbox.prepare
    # 检测PluginManager 是否有pre-install的plugin
    ensure_plugins_are_installed!
    # 执行插件中的pre-install的所有hooks方法
    run_plugins_pre_install_hooks
  end
end</code></pre>
<p>在<code>prepare</code>阶段会将<code>pod install</code>的准备工作完成，包括版本一致性、Pods目录结构创建以及<code>pre-install</code>相关的plugins 脚本执行。</p>
<h5 id="3-依赖分析"><a href="#3-依赖分析" class="headerlink" title="3. 依赖分析"></a>3. 依赖分析</h5><pre><code class="ruby">def resolve_dependencies
  plugin_sources = run_source_provider_hooks
  # Analyzer 是通过分析Podfile、Podfile.lock，沙盒中的manifest，从而生成了一张依赖关系表
  analyzer = create_analyzer(plugin_sources)

  UI.section &#39;Updating local specs repositories&#39; do
    analyzer.update_repositories
  end if repo_update? #pod install --repo-update

  UI.section &#39;Analyzing dependencies&#39; do
    # 从analyzer取出最新的分析结果
    analyze(analyzer)

    # 调试使用~
    @analysis_result.podfile_dependency_cache.podfile_dependencies.each { |item| 
      p item
    }

    p &quot;------analysis_result-------&quot;
    p @analysis_result.podfile_state
    p @analysis_result.sandbox_state

    # Sepicat工程中各个target对应的spec情况
    @analysis_result.specs_by_target.keys.each do |item|
      puts &quot;----#{item}----&quot;
      @analysis_result.specs_by_target[item].each do |sub_item| #specs_by_target查看各个target相关的specs
        p sub_item
      end
    end


    # 校验pod白名单的configuration的有效性 如拼写错误降级识别，白名单过滤
    validate_build_configurations
  end

  # pod install --deployment
  # 禁止在install 过程中变更 Podfile/Podfile.lock
  UI.section &#39;Verifying no changes&#39; do
    verify_no_podfile_changes!
    verify_no_lockfile_changes!
  end if deployment?

  analyzer
end</code></pre>
<p>依赖解析过程会通过<code>Podfile</code>、<code>Podfild.lock</code>、<code>manifest</code>文件来生成一个<code>Analyzer</code>对象，在<code>Analyzer</code>内部会使用<strong>Molinillo</strong>。</p>
<pre><code class="ruby">def analyze(analyzer = create_analyzer)
  @analysis_result = analyzer.analyze
  @aggregate_targets = @analysis_result.targets
  @pod_targets = @analysis_result.pod_targets
end</code></pre>
<p><code>analyzer.analyze</code>会调用<code>resolve_dependencies</code>方法，最终会调用<code>Resolver</code>的<code>resolve</code>方法：</p>
<pre><code class="ruby">def resolve
  dependencies = @podfile_dependency_cache.target_definition_list.flat_map do |target|
    @podfile_dependency_cache.target_definition_dependencies(target).each do |dep|
      next unless target.platform
      @platforms_by_dependency[dep].push(target.platform)
    end
  end.uniq
  @platforms_by_dependency.each_value(&amp;:uniq!)
  @activated = Molinillo::Resolver.new(self, self).resolve(dependencies, locked_dependencies)
  resolver_specs_by_target
rescue Molinillo::ResolverError =&gt; e
  handle_resolver_error(e)
end</code></pre>
<p>这里的<code>Molinillo::Resolver</code>就是用于解决依赖关系的类。 <code>Milinillo</code>算法的核心是回溯(Backtracking)、向前检查(forward check)，整个过程会追踪栈中的两个状态（依赖和可能性）。</p>
<p>Resolver的大概过程如下：</p>
<p><img src="https://raw.githubusercontent.com/liututu1213/imageForSource/master/CocoaPods/Resolver.png" srcset="/img/loading.gif" alt=""></p>
<p>下面是调试输出的日志：</p>
<p><code>podfile_dependency_cache.podfile_dependencies</code>:</p>
<pre><code>&lt;Pod::Dependency name=AFNetworking requirements== 1.3.3 source=nil external_source=nil&gt;
&lt;Pod::Dependency name=SDWebImage requirements=&gt;= 0 source=nil external_source=nil&gt;
&lt;Pod::Dependency name=Moya requirements=&gt;= 0 source=nil external_source=nil&gt;
&lt;Pod::Dependency name=SnapKit requirements=&gt;= 0 source=nil external_source=nil&gt;</code></pre><p><code>@analysis_result.podfile_state</code>和 <code>@analysis_result.sandbox_state</code>分别的输出是：</p>
<pre><code>#&lt;Pod::Installer::Analyzer::SpecsState:0x00007ff58bbb5fc0 @added=#&lt;Set: {}&gt;, @deleted=#&lt;Set: {}&gt;, @changed=#&lt;Set: {}&gt;, @unchanged=#&lt;Set: {&quot;AFNetworking&quot;, &quot;Moya&quot;, &quot;SDWebImage&quot;, &quot;SnapKit&quot;}&gt;&gt;
#&lt;Pod::Installer::Analyzer::SpecsState:0x00007ff58bbec980 @added=#&lt;Set: {}&gt;, @deleted=#&lt;Set: {}&gt;, @changed=#&lt;Set: {}&gt;, @unchanged=#&lt;Set: {&quot;AFNetworking&quot;, &quot;Alamofire&quot;, &quot;Moya&quot;, &quot;Result&quot;, &quot;SDWebImage&quot;, &quot;SnapKit&quot;}&gt;&gt;</code></pre><p><code>analysis_result.specs_by_target</code>查看各个target相关的specs</p>
<pre><code>----Pods-AFNetworking Example----
#&lt;Pod::Specification name=&quot;AFNetworking&quot;&gt;
----Pods-AFNetworking iOS Example----
#&lt;Pod::Specification name=&quot;AFNetworking&quot;&gt;
#&lt;Pod::Specification name=&quot;Alamofire&quot;&gt;
#&lt;Pod::Specification name=&quot;Moya&quot;&gt;
#&lt;Pod::Specification name=&quot;Moya/Core&quot;&gt;
#&lt;Pod::Specification name=&quot;Result&quot;&gt;
#&lt;Pod::Specification name=&quot;SDWebImage&quot;&gt;
#&lt;Pod::Specification name=&quot;SDWebImage/Core&quot;&gt;
#&lt;Pod::Specification name=&quot;SnapKit&quot;&gt;</code></pre><h5 id="4-依赖下载"><a href="#4-依赖下载" class="headerlink" title="4. 依赖下载"></a>4. 依赖下载</h5><pre><code class="ruby">def download_dependencies
  UI.section &#39;Downloading dependencies&#39; do
    # 构造Pod Source Installer
    install_pod_sources
    # 执行pre install 的hooks
    run_podfile_pre_install_hooks
    clean_pod_sources
  end
end</code></pre>
<p>下面是<code>install_pod_sources</code>方法的实现：</p>
<pre><code class="ruby">def install_pod_sources
  @installed_specs = []
  # install的Pod只需要两种状态：added和changed状态的并集
  pods_to_install = sandbox_state.added | sandbox_state.changed
  title_options = { :verbose_prefix =&gt; &#39;-&gt; &#39;.green }


  # 将Podfile解析后排序处理
  root_specs.sort_by(&amp;:name).each do |spec|
    # 如果Pod是added或者changed状态
    if pods_to_install.include?(spec.name)
      # 如果是changed状态并且是manifest 已经有记录
      if sandbox_state.changed.include?(spec.name) &amp;&amp; sandbox.manifest
        # 版本更新
        current_version = spec.version
        # 被更新版本记录
        previous_version = sandbox.manifest.version(spec.name)
        # 变动记录
        has_changed_version = current_version != previous_version
        # 找到第一个包含spec.name的Pod，获取对应的Repo
        current_repo = analysis_result.specs_by_source.detect { |key, values| break key if values.map(&amp;:name).include?(spec.name) }
        # 获取当前的仓库
        current_repo &amp;&amp;= current_repo.url || current_repo.name
        # 是否仓库有变动
        previous_spec_repo = sandbox.manifest.spec_repo(spec.name)
        has_changed_repo = !previous_spec_repo.nil? &amp;&amp; current_repo &amp;&amp; !current_repo.casecmp(previous_spec_repo).zero?
        title = &quot;Installing #{spec.name} #{spec.version}&quot;
        title &lt;&lt; &quot; (was #{previous_version} and source changed to `#{current_repo}` from `#{previous_spec_repo}`)&quot; if has_changed_version &amp;&amp; has_changed_repo
        title &lt;&lt; &quot; (was #{previous_version})&quot; if has_changed_version &amp;&amp; !has_changed_repo
        title &lt;&lt; &quot; (source changed to `#{current_repo}` from `#{previous_spec_repo}`)&quot; if !has_changed_version &amp;&amp; has_changed_repo
      else
        # 非changed状态
        title = &quot;Installing #{spec}&quot;
      end
      UI.titled_section(title.green, title_options) do
        # 通过name拿到对应的installer，记录到@pod_installer中
        install_source_of_pod(spec.name)
      end
    else
      #如果没有changed情况,则创建一个PodSourceInstaller实例
      UI.section(&quot;Using #{spec}&quot;.red, title_options[:verbose_prefix]) do
        create_pod_installer(spec.name)
      end
    end
  end
end</code></pre>
<p>这个方法主要是根据依赖分析的结果，根据Pod的状态的不同进行不同的处理，如果在<code>pods_to_install</code>里面则安装Pod<code>install_source_of_pod</code>，否则直接走<code>create_pod_installer</code>方法，直接从缓存中取。</p>
<pre><code class="ruby"># 通过缓存返回PodSourceInstaller实例
def create_pod_installer(pod_name)
  specs_by_platform = specs_for_pod(pod_name)

  if specs_by_platform.empty?
    requiring_targets = pod_targets.select { |pt| pt.recursive_dependent_targets.any? { |dt| dt.pod_name == pod_name } }
    message = &quot;Could not install &#39;#{pod_name}&#39; pod&quot;
    message += &quot;, dependended upon by #{requiring_targets.to_sentence}&quot; unless requiring_targets.empty?
    message += &#39;. There is either no platform to build for, or no target to build.&#39;
    raise StandardError, message
  end

  # 通过sandbox，specs的platform信息生成Installer实例
  pod_installer = PodSourceInstaller.new(sandbox, podfile, specs_by_platform, :can_cache =&gt; installation_options.clean?)
  pod_installers &lt;&lt; pod_installer
  pod_installer
end

# 安装Pods,如果resolver声明一个Pod已经安装或者已经存在则将其删除并重新安装
# 如果不存在则直接安装
def install_source_of_pod(pod_name)
  pod_installer = create_pod_installer(pod_name)
  pod_installer.install!
  @installed_specs.concat(pod_installer.specs_by_platform.values.flatten.uniq)
end</code></pre>
<p><code>pod_installer</code>会调用<code>install!</code>方法(pod_source_installer.rb)：</p>
<pre><code class="ruby">def install!
  # 如果未经历过pre-download阶段或者local阶段的Pod，则通过对应的Source下载
  download_source unless predownloaded? || local?
  # 执行Spec 中的Prepar Command
  PodSourcePreparer.new(root_spec, root).prepare! if local?
  sandbox.remove_local_podspec(name) unless predownloaded? || local? || external?
end

def download_source
  verify_source_is_secure(root_spec)
  download_result = Downloader.download(download_request, root, :can_cache =&gt; can_cache?)

  if (specific_source = download_result.checkout_options) &amp;&amp; specific_source != root_spec.source
    sandbox.store_checkout_source(root_spec.name, specific_source)
  end
end</code></pre>
<p>上面的方法主要是将Pod通过对应的source下载下来，会去调用<code>Downloader</code>组件处理所有的下载的逻辑</p>
<h5 id="5-targets-校验"><a href="#5-targets-校验" class="headerlink" title="5. targets 校验"></a>5. targets 校验</h5><p><code>validate_targets</code>过程是用来验证之前流程中的产物Pod所生成的targets的合法性方法。</p>
<pre><code class="ruby">def validate_targets
  validator = Xcode::TargetValidator.new(aggregate_targets, pod_targets, installation_options)
  validator.validate!
end

# target_validator.rb
def validate!
  # 重名检测
  verify_no_duplicate_framework_and_library_names
  # 用来验证动态库是否有静态库或者framework静态库
  verify_no_static_framework_transitive_dependencies
  # 验证Pod中是否指明多个Swift版本，如果有的话需要检测这些依赖是否需要进行build
  verify_swift_pods_swift_version
  # 验证Swift 的Pod是否有module依赖
  verify_swift_pods_have_module_dependencies
  verify_no_multiple_project_names if installation_options.generate_multiple_pod_projects?
end</code></pre>
<p><code>verify_no_static_framework_transitive_dependencies</code>这个方法是用来验证动态库中是否有.a或.framework的静态库，场景：A组件依赖B组件，B组件中通过<code>vendored_libraries</code>方式加载的静态库(.a、.framework)，如果此时在Podfile里面使用了<code>use_framework!</code>,在打包的时候<code>framework</code>会将<code>vendored_libraries</code>中的内容包括进来，这个时候就在符号决议的时候产生冲突，在混合开发的项目里面，动态库中依赖静态库的场景还是很常见的，可以查看这篇组件化的文章：<a href="https://www.valiantcat.cn/index.php/2017/04/24/45.html" target="_blank" rel="noopener">组件化-动态库实战</a>。</p>
<pre><code>The &#39;Pods-xx&#39; target has transitive dependencies that include static binaries: (static_libs.to_sentence)
</code></pre><p>在swift项目中，必须使用<code>use_framework!</code>（目前Cocoapods1.5宣布已经支持Swift使用静态库），因此经常会遇到上述的问题。  </p>
<p>除了文章中这种处理方式，还可以通过修改cocoapods相关的参数达到目的：  </p>
<p>1.修改pod库中的<code>podspec</code>，增加<code>pod_target_xcconfig</code>(表示pod本身被依赖时，修改的编译选项，而user_target_xcconfig表示修改依赖pod的项目的编译选项)</p>
<pre><code class="ruby">s.pod_target_xcconfig = {
    &#39;FRAMEWORK_SEARCH_PATHS&#39; =&gt; &#39;$(inherited) $(PODS_ROOT)/AlipaySDKIniOS&#39;,
    &#39;OTHER_LDFLAGS&#39;          =&gt; &#39;$(inherited) -undefined dynamic_lookup&#39;
}</code></pre>
<p>2.hook    <code>verify_no_static_framework_transitive_dependencies</code>方法，不对动态库依赖静态做检测</p>
<pre><code class="ruby">pre_install do |installer|
    # workaround for https://github.com/CocoaPods/CocoaPods/issues/3289
    def installer.verify_no_static_framework_transitive_dependencies; end
end</code></pre>
<p>特别说明下<code>vendored_libraries</code>是用来在<code>podspec</code>中指定依赖的静态库.a或.framework，如``s.vendored_libraries = ‘libWeiboSDK/libWeiboSDK.a’`。</p>
<h5 id="6-集成"><a href="#6-集成" class="headerlink" title="6. 集成"></a>6. 集成</h5><p> <code>generate_pods_project</code>会把所有的组件通过Project文件的形式组织起啦，并且对Project做一些用户指定的配置。</p>
<pre><code class="ruby">def integrate
  # 生成外层项目
  generate_pods_project
  if installation_options.integrate_targets?
    # 集成用户配置，读取依赖项，使用xcconfig来配置
    integrate_user_project
  else
    UI.section &#39;Skipping User Project Integration&#39;
  end
end

def generate_pods_project
  stage_sandbox(sandbox, pod_targets)

  cache_analysis_result = analyze_project_cache
  pod_targets_to_generate = cache_analysis_result.pod_targets_to_generate
  aggregate_targets_to_generate = cache_analysis_result.aggregate_targets_to_generate

  clean_sandbox(pod_targets_to_generate)

  # 
  create_and_save_projects(pod_targets_to_generate, aggregate_targets_to_generate,
                           cache_analysis_result.build_configurations, cache_analysis_result.project_object_version)
  SandboxDirCleaner.new(sandbox, pod_targets, aggregate_targets).clean!

  update_project_cache(cache_analysis_result, target_installation_results)
end

def integrate_user_project
  UI.section &quot;Integrating client #{&#39;project&#39;.pluralize(aggregate_targets.map(&amp;:user_project_path).uniq.count)}&quot; do

    installation_root = config.installation_root
    integrator = UserProjectIntegrator.new(podfile, sandbox, installation_root, aggregate_targets, generated_aggregate_targets,
                                           :use_input_output_paths =&gt; !installation_options.disable_input_output_paths?)
    integrator.integrate!
  end
end</code></pre>
<p>在<code>~/lib/cocoapods/installer/user_project_integrator.rb</code>文件中的<code>integrate</code>方法：</p>
<pre><code class="ruby">def integrate!
  create_workspace
  deintegrated_projects = deintegrate_removed_targets
  integrate_user_targets
  warn_about_xcconfig_overrides
  projects_to_save = (user_projects_to_integrate + deintegrated_projects).uniq
  save_projects(projects_to_save)
end</code></pre>
<h3 id="pod-install-vs-pod-update"><a href="#pod-install-vs-pod-update" class="headerlink" title="pod install vs pod update"></a>pod install vs pod update</h3><p>在<a href="https://guides.cocoapods.org/using/pod-install-vs-update.html" target="_blank" rel="noopener">cocoapods guides</a> 中对于<code>pod install</code> vs <code>pod update</code>区别的翻译如下：</p>
<p>1.在项目中第一次使用Cocoapods时（即没有<code>Podfile.lock</code>文件的情况），或者在podfile中添加、删除、更新pods时，可使用<code>pod install</code>下载安装pod。</p>
<p>2.<code>pod update [PODNAME]</code>用在需要更新pods的最新版本时</p>
<h4 id="pod-install"><a href="#pod-install" class="headerlink" title="pod install"></a>pod install</h4><p>除了在新建工程时，需用到<code>pod install</code>，在后续执行<code>pod install</code>时，对于已经列在<code>podfile.lock</code>中的pod，它会下载lock锁定的版本，而不会去检查是否有最新的可用版本，对于没有在podfile.lock中文件的库，会根据podfile文件中指定的版本去下载符合指定返回内最新的版本。</p>
<h5 id="pod-update"><a href="#pod-update" class="headerlink" title="pod update"></a>pod update</h5><pre><code class="ruby"># update.rb
installer.repo_update = repo_update?(:default =&gt; true)
installer.update = false

# analyzer.rb
deleted_and_changed += pods_to_update[:pods] if update_mode == :selected</code></pre>
<p><code>pod update [PODNAME]</code>命令，首先会更新本地的spec 仓库，<code>pod install</code>默认的<code>repo_update</code>为<code>false</code>。其次会忽略podfile.lock中的锁定的版本，更新到podfile中指定的版本。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/6648/2020/01/18/Ruby%E5%9F%BA%E7%A1%80/" rel="prev" title="Ruby基础">
      <i class="fa fa-chevron-left"></i> Ruby基础
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/44783/2020/02/26/Moya/" rel="next" title="Moya && Alamofire">
      Moya && Alamofire <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Debug-Cocoapods"><span class="nav-number">1.</span> <span class="nav-text">Debug Cocoapods</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pod-install的分析"><span class="nav-number">2.</span> <span class="nav-text">pod install的分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pod-命令的入口"><span class="nav-number">2.1.</span> <span class="nav-text">pod  命令的入口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pod-install主流程分析"><span class="nav-number">2.2.</span> <span class="nav-text">pod install主流程分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-installer-for-config"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.  installer_for_config</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-prepare"><span class="nav-number">2.2.2.</span> <span class="nav-text">2. prepare</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-依赖分析"><span class="nav-number">2.2.3.</span> <span class="nav-text">3. 依赖分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-依赖下载"><span class="nav-number">2.2.4.</span> <span class="nav-text">4. 依赖下载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-targets-校验"><span class="nav-number">2.2.5.</span> <span class="nav-text">5. targets 校验</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-集成"><span class="nav-number">2.2.6.</span> <span class="nav-text">6. 集成</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pod-install-vs-pod-update"><span class="nav-number">3.</span> <span class="nav-text">pod install vs pod update</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#pod-install"><span class="nav-number">3.1.</span> <span class="nav-text">pod install</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#pod-update"><span class="nav-number">3.1.1.</span> <span class="nav-text">pod update</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liututu1213</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liututu1213</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
