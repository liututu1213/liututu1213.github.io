<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="渣渣程序员">
<meta property="og:url" content="https://github.com/liututu1213/liututu1213.github.io/index.html">
<meta property="og:site_name" content="渣渣程序员">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="liututu1213">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://github.com/liututu1213/liututu1213.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>渣渣程序员</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="渣渣程序员" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">渣渣程序员</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/liututu1213/liututu1213.github.io/blog/44783/2020/02/26/Moya/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liututu1213">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渣渣程序员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/44783/2020/02/26/Moya/" class="post-title-link" itemprop="url">Moya && Alamofire</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-26 00:05:39" itemprop="dateCreated datePublished" datetime="2020-02-26T00:05:39+08:00">2020-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-25 22:30:30" itemprop="dateModified" datetime="2020-05-25T22:30:30+08:00">2020-05-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/swift/" itemprop="url" rel="index"><span itemprop="name">swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对Moya和Alamofire的分析基于以下版本：Alamofire (4.9.1) 、Moya (13.0.1)。</p>
<h2 id="Moya"><a href="#Moya" class="headerlink" title="Moya"></a>Moya</h2><p>Moya的目录结构如下：</p>
<pre><code>├── Moya
│   ├── AnyEncodable.swift
│   ├── Cancellable.swift
│   ├── Endpoint.swift
│   ├── Image.swift
│   ├── Moya+Alamofire.swift
│   ├── MoyaError.swift
│   ├── MoyaProvider+Defaults.swift
│   ├── MoyaProvider+Internal.swift
│   ├── MoyaProvider.swift
│   ├── MultiTarget.swift
│   ├── MultipartFormData.swift
│   ├── Plugin.swift
│   ├── Plugins
│   │   ├── AccessTokenPlugin.swift
│   │   ├── CredentialsPlugin.swift
│   │   ├── NetworkActivityPlugin.swift
│   │   └── NetworkLoggerPlugin.swift
│   ├── Response.swift
│   ├── TargetType.swift
│   ├── Task.swift
│   ├── URL+Moya.swift
│   ├── URLRequest+Encoding.swift
│   └── ValidationType.swift
├── ReactiveMoya
│   ├── MoyaProvider+Reactive.swift
│   └── SignalProducer+Response.swift
└── RxMoya
    ├── MoyaProvider+Rx.swift
    ├── Observable+Response.swift
    └── Single+Response.swift</code></pre><h3 id="Moya介绍"><a href="#Moya介绍" class="headerlink" title="Moya介绍"></a>Moya介绍</h3><p>Moya是基于Alamofire的更高一层的网络请求封装抽象层，在Moya中使用Enum来管理API，每一个网络请求接口都是枚举的一种case，下面是Moya的大概流程图：</p>
<p><img src="https://raw.githubusercontent.com/liututu1213/imageForSource/master/2020/moya.png" alt=""></p>
<h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>request部分主要是包含请求相关的代码，定义了TargetType协议，通过TargetType来定义一个请求。</p>
<ul>
<li>TargetType:请求相关信息</li>
<li>Endpoint：Moya进行请求的最终数据结构</li>
<li>Task：定义了请求的发起方式，请求参数设置等</li>
<li>Cancellable：请求取消相关协议</li>
</ul>
<h3 id="MoyaProvider"><a href="#MoyaProvider" class="headerlink" title="MoyaProvider"></a>MoyaProvider</h3><h4 id="Provider初始化"><a href="#Provider初始化" class="headerlink" title="Provider初始化"></a>Provider初始化</h4><p>MoyaProvider是Moya的核心处理类，Moya中所有的API请求都是通过Provider来发起的。Provider真正做的事情可以用一个流来表示：Target-&gt;Endpoint-&gt;Request,这个过程中Provider会一步步生层一个NSURLRequest来交给Alamofire发起请求。</p>
<pre><code class="swift">public init(endpointClosure: @escaping EndpointClosure = MoyaProvider.defaultEndpointMapping,
            requestClosure: @escaping RequestClosure = MoyaProvider.defaultRequestMapping,
            stubClosure: @escaping StubClosure = MoyaProvider.neverStub,
            callbackQueue: DispatchQueue? = nil,
            manager: Manager = MoyaProvider&lt;Target&gt;.defaultAlamofireManager(),
            plugins: [PluginType] = [],
            trackInflights: Bool = false) {}
</code></pre>
<ul>
<li><p>endpointClosure：负责从TargetType转成Endpoint，Moya对endpointClosure提供了默认的实现。</p>
<pre><code class="swift">final class func defaultEndpointMapping(for target: Target) -&gt; Endpoint {
    return Endpoint(
        url: URL(target: target).absoluteString,
        sampleResponseClosure: { .networkResponse(200, target.sampleData) },
        method: target.method,
        task: target.task,
        httpHeaderFields: target.headers
    )
}</code></pre>
<p>在实际的项目中，可以自定义这个闭包来实现复杂的功能。</p>
</li>
</ul>
<ul>
<li><p>requestClosure：负责把Endpoint转换成NSURLRequest，同样也有默认的实现<code>MoyaProvider.defaultRequestMappin</code></p>
<pre><code class="swift">final class func defaultRequestMapping(for endpoint: Endpoint, closure: RequestResultClosure) {
    do {
        let urlRequest = try endpoint.urlRequest()
        closure(.success(urlRequest))
    } catch MoyaError.requestMapping(let url) {
        closure(.failure(MoyaError.requestMapping(url)))
    } catch MoyaError.parameterEncoding(let error) {
        closure(.failure(MoyaError.parameterEncoding(error)))
    } catch {
        closure(.failure(MoyaError.underlying(error, nil)))
    }
}</code></pre>
</li>
</ul>
<ul>
<li><p>stubClosure：返回一个枚举StubBehavior，默认会返回never，如果需要假数据测试可以重写这个。</p>
<pre><code class="swift">public enum StubBehavior {
    case never
    case immediate
    case delayed(seconds: TimeInterval)
}</code></pre>
</li>
</ul>
<ul>
<li><p>callbackQueue： 回调的线程，默认在主线程。</p>
</li>
<li><p>manager：真正用来请求的类，由Alamofire桥接过来的，Moya提供了一个默认的Manager实现。</p>
<pre><code class="swift">final class func defaultAlamofireManager() -&gt; Manager {
    let configuration = URLSessionConfiguration.default
    configuration.httpAdditionalHeaders = Manager.defaultHTTPHeaders

    let manager = Manager(configuration: configuration)
    manager.startRequestsImmediately = false
    return manager
}</code></pre>
</li>
</ul>
<ul>
<li>plugins：插件，能够在不修改源码的情况下，来扩展其他功能，而且能够保证Provider的职责单一，满足开闭原则。</li>
<li>trackInflights：是否要追踪请求，默认是false。</li>
</ul>
<h4 id="Provider-发起请求实现"><a href="#Provider-发起请求实现" class="headerlink" title="Provider 发起请求实现"></a>Provider 发起请求实现</h4><p><img src="https://raw.githubusercontent.com/liututu1213/imageForSource/master/2020/Provider.png" alt=""></p>
<p>在初始化Provider实例对象之后，对外暴露<code>request</code>方法以便发起请求：</p>
<pre><code class="swift">@discardableResult
open func request(_ target: Target,
                  callbackQueue: DispatchQueue? = .none,
                  progress: ProgressBlock? = .none,
                  completion: @escaping Completion) -&gt; Cancellable {

    let callbackQueue = callbackQueue ?? self.callbackQueue
    return requestNormal(target, callbackQueue: callbackQueue, progress: progress, completion: completion)
}</code></pre>
<p>在swift里面，如果没有接收某方法的返回值，Xcode会报出警告，使用<code>@discardableResult</code>关键字在不想接收方法返回值的时候，用来消除Xcode的警告。</p>
<p>在MoyaProvider+Internal.swift文件中主要定义了十个方法,主要做的事如下图：</p>
<p><img src="https://raw.githubusercontent.com/liututu1213/imageForSource/master/2020/provider-rquest.png" alt=""></p>
<h3 id="Moya-Alamofire"><a href="#Moya-Alamofire" class="headerlink" title="Moya+Alamofire"></a>Moya+Alamofire</h3><p>Moya+Alamofire.swift文件对Alamofire进行了简单的封装，这一层包装隔离了Alamofire的代码，如果需要更换请求框架的话，可以进行简单的修改来替换。</p>
<ul>
<li><p>使用<strong>typealias</strong>对Alamofire相关的的API进行封装：Manager、Request、Method等</p>
</li>
<li><p>让Alamofire相关的类实现Moya定义的一些protocol</p>
<pre><code class="swift">extension Request: RequestType { }
extension DataRequest: Requestable {
   ...
}
extension DownloadRequest: Requestable {
   ...
}</code></pre>
</li>
</ul>
<h3 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h3><p>Moya提供了非常好用的插件机制，可以通过插件在不修改源码的基础上，充分扩展Moya的功能。</p>
<pre><code class="swift">public protocol PluginType {
    /// Called to modify a request before sending.
    func prepare(_ request: URLRequest, target: TargetType) -&gt; URLRequest
    /// Called immediately before a request is sent over the network (or stubbed).
    func willSend(_ request: RequestType, target: TargetType)
    /// Called after a response has been received, but before the MoyaProvider has invoked its completion handler.
    func didReceive(_ result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType)
    /// Called to modify a result before completion.
    func process(_ result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType) -&gt; Result&lt;Moya.Response, MoyaError&gt;
}

public extension PluginType {
    func prepare(_ request: URLRequest, target: TargetType) -&gt; URLRequest { return request }
    func willSend(_ request: RequestType, target: TargetType) { }
    func didReceive(_ result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType) { }
    func process(_ result: Result&lt;Moya.Response, MoyaError&gt;, target: TargetType) -&gt; Result&lt;Moya.Response, MoyaError&gt; { return result }
}</code></pre>
<p>调用方可以实现上面的协议，来创建各种插件处理不同事情，从而保证Provider的单一职责。</p>
<ul>
<li><p>prepare：这个方法会在endpoint生成Request之后且请求发送前调用</p>
<pre><code class="swift">let performNetworking = { (requestResult: Result&lt;URLRequest, MoyaError&gt;) in
    // Allow plugins to modify request
    let preparedRequest = self.plugins.reduce(request) { $1.prepare($0, target: target) }
}</code></pre>
</li>
<li><p>willSend：会在发送Alamofire请求前调用</p>
<pre><code class="swift">func sendAlamofireRequest&lt;T&gt;(_ alamoRequest: T, target: Target, callbackQueue: DispatchQueue?, progress progressCompletion: Moya.ProgressBlock?, completion: @escaping Moya.Completion) -&gt; CancellableToken where T: Requestable, T: Request {
    // Give plugins the chance to alter the outgoing request
    let plugins = self.plugins
    plugins.forEach { $0.willSend(alamoRequest, target: target) }
}</code></pre>
</li>
</ul>
<ul>
<li><p>didReceive：在收到Response的时候调用</p>
<pre><code class="swift">let completionHandler: RequestableCompletion = { response, request, data, error in
    let result = convertResponseToResult(response, request: request, data: data, error: error)
    // Inform all plugins about the response
    plugins.forEach { $0.didReceive(result, target: target) }
    completion(result)
}</code></pre>
</li>
<li><p>process：在请求完成后修改Result。</p>
</li>
</ul>
<h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p>响应结果相关方法，以及字典，JSON等相关转换方法。</p>
<pre><code class="swift">/// Represents a response to a `MoyaProvider.request`.
public final class Response: CustomDebugStringConvertible, Equatable {
    public let statusCode: Int
    public let data: Data
    public let request: URLRequest?
    public let response: HTTPURLResponse?
}</code></pre>
<h4 id="Cancel"><a href="#Cancel" class="headerlink" title="Cancel"></a>Cancel</h4><p>网络API请求是 可以被取消的，Moya返回协议Cancellable给客户端。</p>
<pre><code class="swift">internal class CancellableWrapper: Cancellable {
    internal var innerCancellable: Cancellable = SimpleCancellable()

    var isCancelled: Bool { return innerCancellable.isCancelled }

    internal func cancel() {
        innerCancellable.cancel()
    }
}</code></pre>
<p>在内部实现中，引入了一个CancellableWrapper来进行实际的Cancel包装，返回的实际实现协议的类型就是它。</p>
<p>使用一个CancellableWrapper包装的原因主要是对于没有实际发出的请求(参数错误)，cancel动作直接用SimpleCancellable即可，如果已经发出的请求，cancel则需要取消实际的网络请求。</p>
<p>在<code>CancellableToken</code>中，取消网络请求：</p>
<pre><code class="swift">public final class CancellableToken: Cancellable, CustomDebugStringConvertible {
    fileprivate var lock: DispatchSemaphore = DispatchSemaphore(value: 1)

    public func cancel() {
        _ = lock.wait(timeout: DispatchTime.distantFuture)
        defer { lock.signal() }
        guard !isCancelled else { return }
        isCancelled = true
        cancelAction()
    }
    init(request: Request) {
        self.request = request
        self.cancelAction = {
            request.cancel()
        }
    }
}</code></pre>
<p>这里用到了信号量，为了防止两个线程同时执行cancel操作。</p>
<h3 id="Moya的设计原则"><a href="#Moya的设计原则" class="headerlink" title="Moya的设计原则"></a>Moya的设计原则</h3><p>1.面向协议</p>
<p>swift是一个面向协议的语言，协议建立的是一个抽象的依赖关系，同时Swift协议支持扩展，可以通过扩展为协议中的方法提供默认的实现。</p>
<pre><code>public protocol TargetType {} //表示一个API请求
public protocol Cancellable {} // 唯一确定请求，只有一个接口用力爱取消
public protocol PluginType {} // 插件类型
public protocol RequestType {} // 对外提供的请求类型，隐藏Alamofire的细节</code></pre><p>2.不可变状态</p>
<p>不可变状态是函数式编程的一个核心概念，在Moya中，很多状态都是不可变的。</p>
<pre><code>public protocol TargetType {
    var baseURL: URL { get } // 只读
    ...
}</code></pre><p>3.高阶函数</p>
<p>在swift中，函数是一等公民，可以作为函数的参数和返回值。高阶函数配合函数默认值，是swift开发中进行接口暴露的常用技巧。</p>
<p>4.插件</p>
<p>通过各个节点暴露出插件的接口，让Moya的日志、授权等功能无须耦合到核心代码里，让代码足够灵活性。</p>
<p>5.类型安全</p>
<p>使用枚举来保证类型安全是swift中常用的技巧。</p>
<p>6.错误处理</p>
<p>通过Result类型来处理异步错误。</p>
<pre><code class="swift">/// A public function responsible for converting the result of a `URLRequest` to a Result&lt;Moya.Response, MoyaError&gt;.
public func convertResponseToResult(_ response: HTTPURLResponse?, request: URLRequest?, data: Data?, error: Swift.Error?) -&gt;
    Result&lt;Moya.Response, MoyaError&gt; {
        switch (response, data, error) {
        case let (.some(response), data, .none):
            let response = Moya.Response(statusCode: response.statusCode, data: data ?? Data(), request: request, response: response)
            return .success(response)
        case let (.some(response), _, .some(error)):
            let response = Moya.Response(statusCode: response.statusCode, data: data ?? Data(), request: request, response: response)
            let error = MoyaError.underlying(error, response)
            return .failure(error)
        case let (_, _, .some(error)):
            let error = MoyaError.underlying(error, nil)
            return .failure(error)
        default:
            let error = MoyaError.underlying(NSError(domain: NSURLErrorDomain, code: NSURLErrorUnknown, userInfo: nil), nil)
            return .failure(error)
        }
}
</code></pre>
<p>用Result类型最大的好处是可以不用每一步都处理错误，通过Result类型，可以在最后统一处理错误。</p>
<pre><code>provider.request(...).filter().mapJSON.filter().{ result in
    switch result {
        case let .success(moyaResponse):

        case let .failure(error):
    }
 }</code></pre><h2 id="Alamofire"><a href="#Alamofire" class="headerlink" title="Alamofire"></a>Alamofire</h2><p>Alamofire的目录结构：</p>
<pre><code>├── AFError.swift
├── Alamofire.swift
├── DispatchQueue+Alamofire.swift
├── MultipartFormData.swift
├── NetworkReachabilityManager.swift
├── Notifications.swift
├── ParameterEncoding.swift
├── Request.swift
├── Response.swift
├── ResponseSerialization.swift
├── Result.swift
├── ServerTrustPolicy.swift
├── SessionDelegate.swift
├── SessionManager.swift
├── TaskDelegate.swift
├── Timeline.swift
└── Validation.swift</code></pre><p><img src="https://raw.githubusercontent.com/liututu1213/imageForSource/master/2020/Alamofire.png" alt=""></p>
<h3 id="Alamofire-swift"><a href="#Alamofire-swift" class="headerlink" title="Alamofire.swift"></a>Alamofire.swift</h3><p>该文件主要是给用户提供一些便利的调用方法<code>request</code>、<code>download</code>、<code>upload</code>、<code>stream</code>，以及定义了两个protocol接口，提供将其他类型转换成URL和URLRequest。</p>
<pre><code class="swift">@discardableResult
public func request(
    _ url: URLConvertible,
    method: HTTPMethod = .get,
    parameters: Parameters? = nil,
    encoding: ParameterEncoding = URLEncoding.default,
    headers: HTTPHeaders? = nil)
    -&gt; DataRequest
{
    return SessionManager.default.request(
        url,
        method: method,
        parameters: parameters,
        encoding: encoding,
        headers: headers
    )
}

@discardableResult
public func request(_ urlRequest: URLRequestConvertible) -&gt; DataRequest {
    return SessionManager.default.request(urlRequest)
}
//....</code></pre>
<p>上面是提供给外部发起网络请求的api。</p>
<pre><code class="swift">public protocol URLConvertible {
    func asURL() throws -&gt; URL
}

public protocol URLRequestConvertible {
    func asURLRequest() throws -&gt; URLRequest
}</code></pre>
<p>这个两个protocol主要是负责类型转换的接口。</p>
<h3 id="SessionManager"><a href="#SessionManager" class="headerlink" title="SessionManager"></a>SessionManager</h3><h4 id="1-SessionManager的初始化"><a href="#1-SessionManager的初始化" class="headerlink" title="1.SessionManager的初始化"></a>1.SessionManager的初始化</h4><p>上面的便利方法主要是调用Manager类的单利，Manager类中主要负责Session和Request的初始化，并提供SessionDelegate代理方法的默认实现。在实现代理方法时提供相应的闭包以提供给用户使用该闭包来回调相应的代理方法。</p>
<pre><code class="swift">public static let `default`: SessionManager = {
    let configuration = URLSessionConfiguration.default
    configuration.httpAdditionalHeaders = SessionManager.defaultHTTPHeaders

    return SessionManager(configuration: configuration)
}()</code></pre>
<p>Manager类是以单利的形式对外使用的，创建SessionManager对象时指定了一个默认的<code>URLSessionConfiguration</code>和<code>defaultHTTPHeaders</code>。</p>
<pre><code class="swift">public init(
    configuration: URLSessionConfiguration = URLSessionConfiguration.default,
    delegate: SessionDelegate = SessionDelegate(),
    serverTrustPolicyManager: ServerTrustPolicyManager? = nil) {
    self.delegate = delegate
    self.session = URLSession(configuration: configuration, delegate: delegate, delegateQueue: nil)

    commonInit(serverTrustPolicyManager: serverTrustPolicyManager)
}
private func commonInit(serverTrustPolicyManager: ServerTrustPolicyManager?) {
    session.serverTrustPolicyManager = serverTrustPolicyManager

    delegate.sessionManager = self

    delegate.sessionDidFinishEventsForBackgroundURLSession = { [weak self] session in
        guard let strongSelf = self else { return }
        DispatchQueue.main.async { strongSelf.backgroundCompletionHandler?() }
    }
}</code></pre>
<p>SessionManager的<code>init</code>方法中，初始化了SessionDelegate和URLSession，并并SessionDelegate对象作为URLSession的delegate。</p>
<h4 id="2-Manager的request方法"><a href="#2-Manager的request方法" class="headerlink" title="2.Manager的request方法"></a>2.Manager的request方法</h4><pre><code class="swift">@discardableResult
open func request(
    _ url: URLConvertible,
    method: HTTPMethod = .get,
    parameters: Parameters? = nil,
    encoding: ParameterEncoding = URLEncoding.default,
    headers: HTTPHeaders? = nil)
    -&gt; DataRequest {
    var originalRequest: URLRequest?

    do {
        originalRequest = try URLRequest(url: url, method: method, headers: headers)
        /// 对参数进行编码, 其中encoding方法会根据ParameterEncoding的类型不同返回不同的request
        let encodedURLRequest = try encoding.encode(originalRequest!, with: parameters)
        return request(encodedURLRequest)
    } catch {
        return request(originalRequest, failedWith: error)
    }
}</code></pre>
<p><code>url</code>是一个实现了<code>URLConvertible</code>的对象，<code>method</code>参数表示请求方式（GET、POST、PUT等），<code>parameters</code>就是请求参数，<code>encoding:ParameterEncoding</code>是请求参数的编码方式，在Alamofire的源码里面有URLEncoding、JSONEncoding、PropertyListEncoding，这里默认的是URL 编码。</p>
<pre><code class="swift">@discardableResult
open func request(_ urlRequest: URLRequestConvertible) -&gt; DataRequest {
    var originalRequest: URLRequest?
    do {
        originalRequest = try urlRequest.asURLRequest()
        let originalTask = DataRequest.Requestable(urlRequest: originalRequest!)//return TaskConvertible

        let task = try originalTask.task(session: session, adapter: adapter, queue: queue)
        let request = DataRequest(session: session, requestTask: .data(originalTask, task))
        delegate[task] = request
        if startRequestsImmediately { request.resume() }
        return request
    } catch {
        return request(originalRequest, failedWith: error)
    }
}</code></pre>
<p>上面的<code>request</code>的方法主要是负责通过Session创建DataTask，并用task对象初始化DataRequest类的对象，并将request存入ManagerDelegate类的属性中<code>delegate[task] = request</code>，因为在delegate属性中的代理方法是调用相应的TaskDelegate类的方法。</p>
<p>然后默认调用<code>request.resume</code>发起网络请求。</p>
<h3 id="SessionDelegate"><a href="#SessionDelegate" class="headerlink" title="SessionDelegate"></a>SessionDelegate</h3><p>这个类主要是URLSessionDelegate以及相关子协议的代理类，其中给出了各个代理方法的默认实现，并将URLSessionDelegate的相关代理封装成闭包的形式提供给外部。如果闭包变量不为空则会执行闭包块的内容，而不会执行默认的实现。</p>
<pre><code class="swift">// MARK: URLSessionDelegate Overrides
open var sessionDidReceiveChallenge: ((URLSession, URLAuthenticationChallenge) -&gt; (URLSession.AuthChallengeDisposition, URLCredential?))?
open var sessionDidReceiveChallengeWithCompletion: ((URLSession, URLAuthenticationChallenge, @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -&gt; Void) -&gt; Void)?

// MARK: URLSessionDataDelegate Overrides
open var dataTaskDidReceiveResponse: ((URLSession, URLSessionDataTask, URLResponse) -&gt; URLSession.ResponseDisposition)?

// MARK: URLSessionDownloadDelegate Overrides
// ....

var retrier: RequestRetrier?
weak var sessionManager: SessionManager?

var requests: [Int: Request] = [:]
private let lock = NSLock()
/// Access the task delegate for the specified task in a thread-safe manner.
open subscript(task: URLSessionTask) -&gt; Request? {
    get {
        lock.lock() ; defer { lock.unlock() }
        return requests[task.taskIdentifier]
    }
    set {
        lock.lock() ; defer { lock.unlock() }
        requests[task.taskIdentifier] = newValue
    }
}
extension SessionDelegate: URLSessionDelegate {}
extension SessionDelegate: URLSessionTaskDelegate {}
extension SessionDelegate: URLSessionDataDelegate {}
extension SessionDelegate: URLSessionDownloadDelegate {}
extension SessionDelegate: URLSessionStreamDelegate {}</code></pre>
<ul>
<li><p><code>subscript</code>表示自定义下标，可以通过<code>delegate[task]</code>的形式进行访问；</p>
</li>
<li><p>使用到NSLock来保证线程安全以便在访问指定的task时；</p>
</li>
<li><p><code>requests</code>负责储存request对象，以便SessionDelegate在URLSessionDelegate相应的代理方法中通过<code>self[task]?.delegate</code>，获取到TaskDelegate对象来调用其方法，例如以下的代理方法中的实现：</p>
<pre><code class="swift">open func urlSession(
    _ session: URLSession,
    task: URLSessionTask,
    didReceive challenge: URLAuthenticationChallenge,
    completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -&gt; Void)
{
    guard taskDidReceiveChallengeWithCompletion == nil else {
        taskDidReceiveChallengeWithCompletion?(session, task, challenge, completionHandler)
        return
    }

    if let taskDidReceiveChallenge = taskDidReceiveChallenge {
        let result = taskDidReceiveChallenge(session, task, challenge)
        completionHandler(result.0, result.1)
    } else if let delegate = self[task]?.delegate {
        delegate.urlSession(
            session,
            task: task,
            didReceive: challenge,
            completionHandler: completionHandler
        )
    } else {
        urlSession(session, didReceive: challenge, completionHandler: completionHandler)
    }
}</code></pre>
</li>
</ul>
<h3 id="Request相关类"><a href="#Request相关类" class="headerlink" title="Request相关类"></a>Request相关类</h3><h4 id="1-Request初始化"><a href="#1-Request初始化" class="headerlink" title="1.Request初始化"></a>1.Request初始化</h4><p>Request就是负责通过会话创建各种类型的Task，并给出相应的Task Delegate。</p>
<pre><code class="swift">init(session: URLSession, requestTask: RequestTask, error: Error? = nil) {
    self.session = session

    switch requestTask {
    case .data(let originalTask, let task):
        taskDelegate = DataTaskDelegate(task: task)
        self.originalTask = originalTask
    case .download(let originalTask, let task):
        taskDelegate = DownloadTaskDelegate(task: task)
        self.originalTask = originalTask
    case .upload(let originalTask, let task):
        taskDelegate = UploadTaskDelegate(task: task)
        self.originalTask = originalTask
    case .stream(let originalTask, let task):
        taskDelegate = TaskDelegate(task: task)
        self.originalTask = originalTask
    }

    delegate.error = error
    delegate.queue.addOperation { self.endTime = CFAbsoluteTimeGetCurrent() }
}</code></pre>
<p>初始化方法需要两个参数：第一个参数是URLSession对象，改对象时SessionManager单例持有的session，第二个参数同样是Manager中传过来的<code>RequestTask</code>枚举类型，根据RequestTask的类型来设置代理对象DataDelegate，例如如果是data类型则创建的是DataDelegate的实例。</p>
<h4 id="Request的ProgressHandler闭包"><a href="#Request的ProgressHandler闭包" class="headerlink" title="Request的ProgressHandler闭包"></a>Request的ProgressHandler闭包</h4><p>在使用Request类的对象时，可以链式地调用Request中的方法，最常用的是获取相应任务执行的进度：</p>
<pre><code class="swift">Alamofire.request(URL(string: &quot;https://httpbin.org/get&quot;)!).downloadProgress { (progress) in
    /// progress

}.response { (response) in
    /// response
}</code></pre>
<p>其中DataRequest和DownloadRequest定义的是downloadProgress，UploadRequest定义的是uploadProgress闭包，可以通过这个闭包监听下载或上传的进度。</p>
<h4 id="resume方法"><a href="#resume方法" class="headerlink" title="resume方法"></a>resume方法</h4><pre><code class="swift">open func resume() {
    guard let task = task else { delegate.queue.isSuspended = false ; return }

    if startTime == nil { startTime = CFAbsoluteTimeGetCurrent() }

    task.resume()

    NotificationCenter.default.post(
        name: Notification.Name.Task.DidResume,
        object: self,
        userInfo: [Notification.Key.Task: task]
    )
}
</code></pre>
<p><code>resume</code>方法主要是用来记录startTime，然后调用task的resume方法开始执行任务，并发出相应的通知。</p>
<h3 id="ResponseSerialization"><a href="#ResponseSerialization" class="headerlink" title="ResponseSerialization"></a>ResponseSerialization</h3><p> ResponseSerialization是用来对Response返回的值进行序列化。在文件中定义了两个protocol：<code>DataResponseSerializerProtocol</code>和<code>DownloadResponseSerializerProtocol</code></p>
<pre><code class="swift">public protocol DataResponseSerializerProtocol {
    /// The type of serialized object to be created by this `DataResponseSerializerType`.
    associatedtype SerializedObject
    var serializeResponse: (URLRequest?, HTTPURLResponse?, Data?, Error?) -&gt; Result&lt;SerializedObject&gt; { get }
}

public protocol DownloadResponseSerializerProtocol {
    associatedtype SerializedObject
    var serializeResponse: (URLRequest?, HTTPURLResponse?, URL?, Error?) -&gt; Result&lt;SerializedObject&gt; { get }
}</code></pre>
<p>这两个protocol分别由<code>DataResponseSerializer&lt;Value&gt;</code>和<code>DownloadResponseSerializer&lt;Value&gt;</code>来实现。</p>
<p>在Alamofire中调用DataRequest的的<code>response</code>或者<code>responseJSON</code>等其他方法，就会在request结束时，添加一个操作<code>OperationQueue</code>来处理服务器的response。</p>
<pre><code class="swift">@discardableResult
public func response&lt;T: DataResponseSerializerProtocol&gt;(
    queue: DispatchQueue? = nil,
    responseSerializer: T,
    completionHandler: @escaping (DataResponse&lt;T.SerializedObject&gt;) -&gt; Void)
    -&gt; Self
{
    delegate.queue.addOperation {
        let result = responseSerializer.serializeResponse(
            self.request,
            self.response,
            self.delegate.data,
            self.delegate.error
        )

        var dataResponse = DataResponse&lt;T.SerializedObject&gt;(
            request: self.request,
            response: self.response,
            data: self.delegate.data,
            result: result,
            timeline: self.timeline
        )

        dataResponse.add(self.delegate.metrics)

        (queue ?? DispatchQueue.main).async { completionHandler(dataResponse) }
    }

    return self
}</code></pre>
<p>总结：</p>
<p>在Alamofire框架中使用了协议、扩展、闭包以及枚举关联值，在解析网络数据的时，将闭包类型作为函数的参数，通过闭包变量来提供相应的解析方案。</p>
<ul>
<li><p>Alamofire对泛型的使用：</p>
<pre><code>public enum Result&lt;Value&gt; {}
public func validate&lt;S: Sequence&gt;(contentType acceptableContentTypes: S) -&gt; Self where S.Iterator.Element == String {}
public struct DataResponse&lt;Value&gt; {}</code></pre></li>
<li><p>链式调用</p>
<p>对于Request类。其中很多方法都使用了返回<code>-&gt;Self</code>方法</p>
<pre><code>/// 鉴权
open func authenticate(usingCredential credential: URLCredential) -&gt; Self {}
/// 进度
open func downloadProgress(queue: DispatchQueue = DispatchQueue.main, closure: @escaping ProgressHandler) -&gt; Self {}
///响应
public func response(queue: DispatchQueue? = nil, completionHandler: @escaping (DefaultDataResponse) -&gt; Void) -&gt; Self {}</code></pre></li>
<li><p>顺序创建Task，并保存所有的requests。</p>
<pre><code>delegate[task] = request
open subscript(task: URLSessionTask) -&gt; Request? {
    get {
        lock.lock() ; defer { lock.unlock() }
        return requests[task.taskIdentifier]
    }
    set {
        lock.lock() ; defer { lock.unlock() }
        requests[task.taskIdentifier] = newValue
    }
}</code></pre></li>
<li><p>在URLSession的回调中根据task把回调分发给对应的TaskDelegate</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/liututu1213/liututu1213.github.io/blog/31010/2020/02/12/Cocoapods/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liututu1213">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渣渣程序员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/31010/2020/02/12/Cocoapods/" class="post-title-link" itemprop="url">Cocoapods源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-12 00:57:24" itemprop="dateCreated datePublished" datetime="2020-02-12T00:57:24+08:00">2020-02-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-25 22:30:30" itemprop="dateModified" datetime="2020-05-25T22:30:30+08:00">2020-05-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ruby/" itemprop="url" rel="index"><span itemprop="name">Ruby</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Cocoapods是开发OSX和iOS应用程序的一个第三方库的依赖管理工具，只用这个工具可以简化对组件依赖。更新过程。Cocoapods是用Ruby写的，由若干个gems组成：相关的<a href="https://github.com/CocoaPods">源码</a>。</p>
<ul>
<li><p><strong><a href="https://github.com/CocoaPods/Specs">CocoaPods/Specs</a></strong></p>
<p>这是保存第三方组件podspec文件的仓库，包含了每一个第三方组件所有版本的podsepc文件。</p>
</li>
<li><p><strong><a href="https://github.com/CocoaPods/CocoaPods">CocoaPods/CocoaPods</a></strong></p>
<p>一个面向用户的组件，每当执行<code>pod install</code>等命令时，都会调用这个组价。</p>
</li>
<li><p><strong><a href="https://github.com/CocoaPods/Core">CocoaPods/Core</a></strong></p>
<p>提供支持与Cocoapods相关文件的处理</p>
</li>
<li><p><strong><a href="https://github.com/CocoaPods/Xcodeproj">CocoaPods/Xcodeproj</a></strong></p>
<p>这个gem组件是用来创建和修改Xcode projects，负责所有工程文件的整合。</p>
</li>
<li><p><a href="https://www.rubydoc.info/gems/cocoapods-downloader" target="_blank" rel="noopener">CocoaPods Downloader</a>: 下载器</p>
</li>
<li><p><a href="https://www.rubydoc.info/gems/claide" target="_blank" rel="noopener">CLAide</a>: 命令行参数解析器</p>
</li>
<li><p><a href="https://github.com/CocoaPods/Molinillo">Molinillo</a> 依赖分析</p>
</li>
</ul>
<p>在Cocoapods中，所有的命令都会由<code>Commad</code>派发到对应的类。</p>
<h3 id="Debug-Cocoapods"><a href="#Debug-Cocoapods" class="headerlink" title="Debug Cocoapods"></a>Debug Cocoapods</h3><p>把Cocoapods相关的代码clone下来，Cocoapods项目作为入口，修改Cocoapods/Gemfile，指定每个依赖的path:</p>
<pre><code class="ruby"># 声明Cocoapods对于git 仓库的依赖关系
# 兼容本地git 仓库模式开发
def cp_gem(name, repo_name, branch = &#39;master&#39;, path: false)
  return gem name if SKIP_UNRELEASED_VERSIONS
  # 如果path参数为true，则将在&quot;.../[repo_name]&quot;这个路径下搜索仓库
  opts = if path
           { :path =&gt; &quot;../#{repo_name}&quot; }
         else
           url = &quot;https://github.com/CocoaPods/#{repo_name}.git&quot;
           { :git =&gt; url, :branch =&gt; branch }
         end
  # 返回标准的Gemfile Gem 导入格式
  gem name, opts
end

source &#39;https://rubygems.org&#39;

gemspec

gem &#39;json&#39;, :git =&gt; &#39;https://github.com/segiddins/json.git&#39;, :branch =&gt; &#39;seg-1.7.7-ruby-2.2&#39;

group :development do
  cp_gem &#39;claide&#39;,                &#39;CLAide&#39;, path: &#39;CLAide&#39;
  cp_gem &#39;cocoapods-core&#39;,        &#39;Core&#39;, path: &#39;Core&#39;
  cp_gem &#39;cocoapods-deintegrate&#39;, &#39;cocoapods-deintegrate&#39;
  cp_gem &#39;cocoapods-downloader&#39;,  &#39;cocoapods-downloader&#39;, path: &#39;cocoapods-downloader&#39;
  cp_gem &#39;cocoapods-plugins&#39;,     &#39;cocoapods-plugins&#39;
  cp_gem &#39;cocoapods-search&#39;,      &#39;cocoapods-search&#39;
  cp_gem &#39;cocoapods-stats&#39;,       &#39;cocoapods-stats&#39;
  cp_gem &#39;cocoapods-trunk&#39;,       &#39;cocoapods-trunk&#39;
  cp_gem &#39;cocoapods-try&#39;,         &#39;cocoapods-try&#39;
  cp_gem &#39;molinillo&#39;,             &#39;Molinillo&#39;, path: &#39;Molinillo&#39;
  cp_gem &#39;nanaimo&#39;,               &#39;Nanaimo&#39;
  cp_gem &#39;xcodeproj&#39;,             &#39;Xcodeproj&#39;, path: &#39;Xcodeproj&#39;
  ...
end</code></pre>
<ol>
<li>在Cocoapods目录下，执行<code>bundle install</code></li>
<li>进入CocoaPods/examples/AFNetworking\ Example，执行<code>bundle exec pod install</code></li>
</ol>
<h3 id="pod-install的分析"><a href="#pod-install的分析" class="headerlink" title="pod install的分析"></a>pod install的分析</h3><h4 id="pod-命令的入口"><a href="#pod-命令的入口" class="headerlink" title="pod  命令的入口"></a>pod  命令的入口</h4><p>当输入<code>pod install</code>命令的时候，首先系统会调用这个<code>pod</code>命令，所有的命令都是在<code>/bin</code>目录下存放的脚本。</p>
<pre><code>$ command which pod
/usr/local/bin/pod</code></pre><p>打开这个入口脚本<code>pod</code>文件：</p>
<pre><code class="ruby">#!/System/Library/Frameworks/Ruby.framework/Versions/2.6/usr/bin/ruby
#
# This file was generated by RubyGems.
#
# The application &#39;cocoapods&#39; is installed as part of a gem, and
# this file is here to facilitate running it.
#

require &#39;rubygems&#39;

version = &quot;&gt;= 0.a&quot;

str = ARGV.first
if str
  # \A代表输入开始的位置，\z代表输入的结束
  str = str.b[/\A_(.*)_\z/, 1]
  if str and Gem::Version.correct?(str)
    version = str
    # shift 拿出第一个元素并移除
    ARGV.shift
  end
end

if Gem.respond_to?(:activate_bin_path)
load Gem.activate_bin_path(&#39;cocoapods&#39;, &#39;pod&#39;, version)
else
gem &quot;cocoapods&quot;, version
load Gem.bin_path(&quot;cocoapods&quot;, &quot;pod&quot;, version)
end
</code></pre>
<p>入口中将命令的执行指向了Gem组件的Path中，这样就找到了Cocoapods的入口脚本，即在<code>cocoapods/bin</code>目录下的<code>pod</code>。</p>
<pre><code class="ruby">require &#39;cocoapods&#39;

if profile_filename = ENV[&#39;COCOAPODS_PROFILE&#39;]
  require &#39;ruby-prof&#39;
  reporter =
    case (profile_extname = File.extname(profile_filename))
    when &#39;.txt&#39;
      RubyProf::FlatPrinterWithLineNumbers
    when &#39;.html&#39;
      RubyProf::GraphHtmlPrinter
    when &#39;.callgrind&#39;
      RubyProf::CallTreePrinter
    else
      raise &quot;Unknown profiler format indicated by extension: #{profile_extname}&quot;
    end
  File.open(profile_filename, &#39;w&#39;) do |io|
    reporter.new(RubyProf.profile { Pod::Command.run(ARGV) }).print(io)
  end
else
  Pod::Command.run(ARGV)
end</code></pre>
<p>在最后部分，通过调用<code>Pod::Command.run(ARGV)</code>,实例化了一个<code>CLAide::Command</code>对象，用户输入的命令及参数进入CLAide解析阶段，这个是一个命令解析工具，每次命令的执行，其实是对应到具体class的<code>run</code>方法。  </p>
<p>执行<code>pod install</code>的类是<code>Install</code>，继承于<code>Command</code>， 根据Podfile.lock的版本安装项目依赖项：</p>
<pre><code class="ruby">module Pod
  class Command
    class Install &lt; Command
      include RepoUpdate
      include ProjectDirectory
      def self.options
        [
          [&#39;--repo-update&#39;, &#39;Force running `pod repo update` before install&#39;],
          [&#39;--deployment&#39;, &#39;Disallow any changes to the Podfile or the Podfile.lock during installation&#39;],
          [&#39;--clean-install&#39;, &#39;Ignore the contents of the project cache and force a full pod installation. This only &#39; \
            &#39;applies to projects that have enabled incremental installation&#39;],
        ].concat(super).reject { |(name, _)| name == &#39;--no-repo-update&#39; }
      end

      def initialize(argv)
        super
        @deployment = argv.flag?(&#39;deployment&#39;, false)
        @clean_install = argv.flag?(&#39;clean-install&#39;, false)
      end

      def run
        verify_podfile_exists!
        installer = installer_for_config
        installer.repo_update = repo_update?(:default =&gt; false)
        installer.update = false
        installer.deployment = @deployment
        installer.clean_install = @clean_install
        installer.install!
      end
    end
  end
end</code></pre>
<p><code>Install</code>是继承于<code>Command</code>命令的，所以对应的命令为<code>pod install</code>。如下写了一个<code>Test</code>类继承于<code>Command</code>类，实现<code>run</code>方法。</p>
<pre><code class="ruby">module Pod
  class Command
    class Test &lt; Command
      def run
        puts &quot;----Test running--&quot;
      end
    end
  end
end</code></pre>
<p>在命令行输入：</p>
<pre><code>$ bundle exec pod test
----Test running--</code></pre><h4 id="pod-install主流程分析"><a href="#pod-install主流程分析" class="headerlink" title="pod install主流程分析"></a>pod install主流程分析</h4><p><code>installer.rb</code>中的<code>run</code>方法中会从config中取一个<code>installer</code>的实例，再执行<code>install</code>方法，<code>installer</code>还有一个<code>update</code>的属性，这个就是<code>pod install</code>和<code>pod update</code>最大的区别：<code>pod update</code>会忽略Podfile.lock文件，重新对依赖进行分析。</p>
<pre><code class="ruby">module Pod
  class Command
    class Update &lt; Command
      include RepoUpdate
      include ProjectDirectory

      def run
        verify_podfile_exists!

        installer = installer_for_config
        installer.repo_update = repo_update?(:default =&gt; true)
        installer.clean_install = @clean_install
        if @pods.any? || @excluded_pods.any? || @source_pods.any?
          verify_lockfile_exists!
          verify_pods_are_installed!
          verify_excluded_pods_are_installed!

          @pods += @source_pods.select { |pod| config.lockfile.pod_names.include?(pod) }
          @pods = config.lockfile.pod_names.dup if @pods.empty?
          @pods -= @excluded_pods

          installer.update = { :pods =&gt; @pods }
        else
          UI.puts &#39;Update all pods&#39;.yellow
          installer.update = true
        end
        installer.install!
      end
    end
  end
end</code></pre>
<h5 id="1-installer-for-config"><a href="#1-installer-for-config" class="headerlink" title="1.  installer_for_config"></a>1.  installer_for_config</h5><p>Podfile的解析是由<a href="https://github.com/CocoaPods/Core">Core</a>这个模块来完成的。</p>
<pre><code class="ruby">def installer_for_config
  Installer.new(config.sandbox, config.podfile, config.lockfile)
end</code></pre>
<p><code>installer_for_config</code>方法获取config中的podfile、lockfile等信息实例一个<code>installer</code>。</p>
<pre><code class="ruby">def podfile
  @podfile ||= Podfile.from_file(podfile_path) if podfile_path
end</code></pre>
<pre><code class="ruby">def self.from_file(path)
  path = Pathname.new(path)
  unless path.exist?
    raise Informative, &quot;No Podfile exists at path `#{path}`.&quot;
  end

  case path.extname
  when &#39;&#39;, &#39;.podfile&#39;, &#39;.rb&#39;
    Podfile.from_ruby(path)
  when &#39;.yaml&#39;
    Podfile.from_yaml(path)
  else
    raise Informative, &quot;Unsupported Podfile format `#{path}`.&quot;
  end
end</code></pre>
<p>在Cocoapods/lib/cocoapods/config.rb中取出一个<code>Podfile</code>类的实例。<code>from_file</code>这个方法会根据Podfile类型的不同而选择不同的调用路径。</p>
<pre><code class="ruby">def self.from_ruby(path, contents = nil)
  contents ||= File.open(path, &#39;r:utf-8&#39;, &amp;:read) 
  podfile = Podfile.new(path) do
    begin
      eval(contents, nil, path.to_s)
    rescue Exception =&gt; e
      message = &quot;Invalid `#{path.basename}` file: #{e.message}&quot;
      raise DSLError.new(message, path, e, contents)
    end
  end
  podfile
end</code></pre>
<p><code>a ||= b</code>是一个条件赋值运算符，当a是未被定义或者为<code>false</code>，则计算b的值并将结果赋值给a，如果a是并定义且值为<code>true</code>，那么b则不会被计算。</p>
<pre><code class="ruby">module Pod
  class Podfile
    module DSL
      def install!(installation_method, options = {}) end
      def pod(name = nil, *requirements) end
      def podspec(options = nil) end
      def target(name, options = nil) end
      def script_phase(options) end
      def platform(name, target = nil) end
      def project(path, build_configurations = {}) end
      def link_with(*) end
      def use_modular_headers! end
      def use_frameworks!(option = true) end
      def source(source) end
      def pre_install(&amp;block) end
      def post_install(&amp;block) end
      ...
    end
  end
end</code></pre>
<p>在Podfile这个类的顶部，导入<code>include Pod::Podfile::DSL</code> 这行代码，这个<code>DSL</code>模块中定义了Podfile中所有方法。当使用<code>eval</code>执行文件中的代码时，就会执行这个模块里的方法。</p>
<pre><code class="ruby">def target(name, options = nil)
  if options
    raise Informative, &quot;Unsupported options `#{options}` for &quot; \
    &quot;target `#{name}`.&quot;
  end

  parent = current_target_definition
  definition = TargetDefinition.new(name, parent)
  self.current_target_definition = definition
  yield if block_given?
ensure
  self.current_target_definition = parent
end</code></pre>
<p>这个方法会创建一个<code>TargetDefinition</code>类的实例，然后将它赋值给当前环境<code>current_target_definition</code>，这样之后使用<code>pod</code>定义的依赖都会填充在当前的<code>TargetDefinition</code>。</p>
<pre><code class="ruby">def pod(name = nil, *requirements)
    unless name
        raise StandardError, &#39;A dependency requires a name.&#39;
    end

    current_target_definition.store_pod(name, *requirements)
end</code></pre>
<p>pod 主要是指定target依赖项的名称和版本等，如以下方式：</p>
<ul>
<li>指定版本号，其中<code>~&gt; 0.1.2</code>表示版本等于<code>&#39;&gt;= 0.1.2&#39; &amp;&amp; &#39;&lt; 0.2.0&#39;</code>，且在符合要求的情况下总是匹配最新的版本。</li>
<li><code>pod &#39;xx&#39;, :configuration =&gt; &#39;Debug&#39;</code></li>
<li><code>pod &#39;xx&#39;, :subspecs =&gt; [&#39;xx&#39;, &#39;xx&#39;]</code></li>
<li><code>pod &#39;xx&#39;, :path =&gt; &#39;~/xx&#39;</code></li>
<li><code>pod &#39;xx&#39;, :git =&gt; &#39;xx&#39;, :branch =&gt; &#39;dev&#39;</code> 或者<code>:tag =&gt; &#39;&#39;</code>、<code>:commit =&gt; &#39;&#39;</code></li>
</ul>
<p>当<code>pod</code>方法被调用时，会执行target_definition.rb中的<code>store_pod</code>方法，将依赖储存到当前的<code>target</code>的<code>dependencies</code>数组中：</p>
<pre><code class="ruby">def store_pod(name, *requirements)
  return if parse_subspecs(name, requirements) # This parse method must be called first
  parse_inhibit_warnings(name, requirements)
  parse_modular_headers(name, requirements)
  parse_configuration_whitelist(name, requirements)
  parse_project_name(name, requirements)

  if requirements &amp;&amp; !requirements.empty?
    pod = { name =&gt; requirements }
  else
    pod = name
  end

  get_hash_value(&#39;dependencies&#39;, []) &lt;&lt; pod
  nil
end
</code></pre>
<p>总结：Cocoapods对Podfile的解析简单概括就是构建了一个包含一些方法的上下文<code>DSL</code>，然后直接执行<code>eval</code>方法将文件的内容当做代码来执行，并将相应解析出来的数据储存到具体的类中。</p>
<p>在<code>installer</code>实例组装完成后，调用其<code>installer.install!</code>方法，进入<code>pod install</code>命令执行的主体部分。</p>
<pre><code class="ruby">def install!
  # 检测是否在Pods内部，如果不是则做一些install前准备工作
  prepare
  # 依赖图的解析
  resolve_dependencies
  # 依赖下载
  download_dependencies
  # 检验之前流程中的产物Pod所生成的Targets的合法性
  validate_targets
  if installation_options.skip_pods_project_generation?
    show_skip_pods_project_generation_message
  else
    integrate
  end
  write_lockfiles
  # 执行任何install 后的操作， 例如一些plugin 可以插入在这里
  perform_post_install_actions
end</code></pre>
<h5 id="2-prepare"><a href="#2-prepare" class="headerlink" title="2. prepare"></a>2. prepare</h5><p><code>prepare</code>方法的实现如下：</p>
<pre><code class="ruby">def prepare
  # Raise if pwd is inside Pods
  # 检测当前目录是项目根目录，直接抛出错误
  if Dir.pwd.start_with?(sandbox.root.to_path)
    message = &#39;Command should be run from a directory outside Pods directory.&#39;
    message &lt;&lt; &quot;\n\n\tCurrent directory is #{UI.path(Pathname.pwd)}\n&quot;
    raise Informative, message
  end
  UI.message &#39;Preparing&#39; do
    # 如果lock文件的Cocoapods版本和当前的版本不同，需要使用新版本依赖的xcodeproj对工程文件进行更新
    deintegrate_if_different_major_version
    # 对sandbox（Pods）目录建立子目录结构
    sandbox.prepare
    # 检测PluginManager 是否有pre-install的plugin
    ensure_plugins_are_installed!
    # 执行插件中的pre-install的所有hooks方法
    run_plugins_pre_install_hooks
  end
end</code></pre>
<p>在<code>prepare</code>阶段会将<code>pod install</code>的准备工作完成，包括版本一致性、Pods目录结构创建以及<code>pre-install</code>相关的plugins 脚本执行。</p>
<h5 id="3-依赖分析"><a href="#3-依赖分析" class="headerlink" title="3. 依赖分析"></a>3. 依赖分析</h5><pre><code class="ruby">def resolve_dependencies
  plugin_sources = run_source_provider_hooks
  # Analyzer 是通过分析Podfile、Podfile.lock，沙盒中的manifest，从而生成了一张依赖关系表
  analyzer = create_analyzer(plugin_sources)

  UI.section &#39;Updating local specs repositories&#39; do
    analyzer.update_repositories
  end if repo_update? #pod install --repo-update

  UI.section &#39;Analyzing dependencies&#39; do
    # 从analyzer取出最新的分析结果
    analyze(analyzer)

    # 调试使用~
    @analysis_result.podfile_dependency_cache.podfile_dependencies.each { |item| 
      p item
    }

    p &quot;------analysis_result-------&quot;
    p @analysis_result.podfile_state
    p @analysis_result.sandbox_state

    # Sepicat工程中各个target对应的spec情况
    @analysis_result.specs_by_target.keys.each do |item|
      puts &quot;----#{item}----&quot;
      @analysis_result.specs_by_target[item].each do |sub_item| #specs_by_target查看各个target相关的specs
        p sub_item
      end
    end


    # 校验pod白名单的configuration的有效性 如拼写错误降级识别，白名单过滤
    validate_build_configurations
  end

  # pod install --deployment
  # 禁止在install 过程中变更 Podfile/Podfile.lock
  UI.section &#39;Verifying no changes&#39; do
    verify_no_podfile_changes!
    verify_no_lockfile_changes!
  end if deployment?

  analyzer
end</code></pre>
<p>依赖解析过程会通过<code>Podfile</code>、<code>Podfild.lock</code>、<code>manifest</code>文件来生成一个<code>Analyzer</code>对象，在<code>Analyzer</code>内部会使用<strong>Molinillo</strong>。</p>
<pre><code class="ruby">def analyze(analyzer = create_analyzer)
  @analysis_result = analyzer.analyze
  @aggregate_targets = @analysis_result.targets
  @pod_targets = @analysis_result.pod_targets
end</code></pre>
<p><code>analyzer.analyze</code>会调用<code>resolve_dependencies</code>方法，最终会调用<code>Resolver</code>的<code>resolve</code>方法：</p>
<pre><code class="ruby">def resolve
  dependencies = @podfile_dependency_cache.target_definition_list.flat_map do |target|
    @podfile_dependency_cache.target_definition_dependencies(target).each do |dep|
      next unless target.platform
      @platforms_by_dependency[dep].push(target.platform)
    end
  end.uniq
  @platforms_by_dependency.each_value(&amp;:uniq!)
  @activated = Molinillo::Resolver.new(self, self).resolve(dependencies, locked_dependencies)
  resolver_specs_by_target
rescue Molinillo::ResolverError =&gt; e
  handle_resolver_error(e)
end</code></pre>
<p>这里的<code>Molinillo::Resolver</code>就是用于解决依赖关系的类。 <code>Milinillo</code>算法的核心是回溯(Backtracking)、向前检查(forward check)，整个过程会追踪栈中的两个状态（依赖和可能性）。</p>
<p>Resolver的大概过程如下：</p>
<p><img src="https://raw.githubusercontent.com/liututu1213/imageForSource/master/CocoaPods/Resolver.png" alt=""></p>
<p>下面是调试输出的日志：</p>
<p><code>podfile_dependency_cache.podfile_dependencies</code>:</p>
<pre><code>&lt;Pod::Dependency name=AFNetworking requirements== 1.3.3 source=nil external_source=nil&gt;
&lt;Pod::Dependency name=SDWebImage requirements=&gt;= 0 source=nil external_source=nil&gt;
&lt;Pod::Dependency name=Moya requirements=&gt;= 0 source=nil external_source=nil&gt;
&lt;Pod::Dependency name=SnapKit requirements=&gt;= 0 source=nil external_source=nil&gt;</code></pre><p><code>@analysis_result.podfile_state</code>和 <code>@analysis_result.sandbox_state</code>分别的输出是：</p>
<pre><code>#&lt;Pod::Installer::Analyzer::SpecsState:0x00007ff58bbb5fc0 @added=#&lt;Set: {}&gt;, @deleted=#&lt;Set: {}&gt;, @changed=#&lt;Set: {}&gt;, @unchanged=#&lt;Set: {&quot;AFNetworking&quot;, &quot;Moya&quot;, &quot;SDWebImage&quot;, &quot;SnapKit&quot;}&gt;&gt;
#&lt;Pod::Installer::Analyzer::SpecsState:0x00007ff58bbec980 @added=#&lt;Set: {}&gt;, @deleted=#&lt;Set: {}&gt;, @changed=#&lt;Set: {}&gt;, @unchanged=#&lt;Set: {&quot;AFNetworking&quot;, &quot;Alamofire&quot;, &quot;Moya&quot;, &quot;Result&quot;, &quot;SDWebImage&quot;, &quot;SnapKit&quot;}&gt;&gt;</code></pre><p><code>analysis_result.specs_by_target</code>查看各个target相关的specs</p>
<pre><code>----Pods-AFNetworking Example----
#&lt;Pod::Specification name=&quot;AFNetworking&quot;&gt;
----Pods-AFNetworking iOS Example----
#&lt;Pod::Specification name=&quot;AFNetworking&quot;&gt;
#&lt;Pod::Specification name=&quot;Alamofire&quot;&gt;
#&lt;Pod::Specification name=&quot;Moya&quot;&gt;
#&lt;Pod::Specification name=&quot;Moya/Core&quot;&gt;
#&lt;Pod::Specification name=&quot;Result&quot;&gt;
#&lt;Pod::Specification name=&quot;SDWebImage&quot;&gt;
#&lt;Pod::Specification name=&quot;SDWebImage/Core&quot;&gt;
#&lt;Pod::Specification name=&quot;SnapKit&quot;&gt;</code></pre><h5 id="4-依赖下载"><a href="#4-依赖下载" class="headerlink" title="4. 依赖下载"></a>4. 依赖下载</h5><pre><code class="ruby">def download_dependencies
  UI.section &#39;Downloading dependencies&#39; do
    # 构造Pod Source Installer
    install_pod_sources
    # 执行pre install 的hooks
    run_podfile_pre_install_hooks
    clean_pod_sources
  end
end</code></pre>
<p>下面是<code>install_pod_sources</code>方法的实现：</p>
<pre><code class="ruby">def install_pod_sources
  @installed_specs = []
  # install的Pod只需要两种状态：added和changed状态的并集
  pods_to_install = sandbox_state.added | sandbox_state.changed
  title_options = { :verbose_prefix =&gt; &#39;-&gt; &#39;.green }


  # 将Podfile解析后排序处理
  root_specs.sort_by(&amp;:name).each do |spec|
    # 如果Pod是added或者changed状态
    if pods_to_install.include?(spec.name)
      # 如果是changed状态并且是manifest 已经有记录
      if sandbox_state.changed.include?(spec.name) &amp;&amp; sandbox.manifest
        # 版本更新
        current_version = spec.version
        # 被更新版本记录
        previous_version = sandbox.manifest.version(spec.name)
        # 变动记录
        has_changed_version = current_version != previous_version
        # 找到第一个包含spec.name的Pod，获取对应的Repo
        current_repo = analysis_result.specs_by_source.detect { |key, values| break key if values.map(&amp;:name).include?(spec.name) }
        # 获取当前的仓库
        current_repo &amp;&amp;= current_repo.url || current_repo.name
        # 是否仓库有变动
        previous_spec_repo = sandbox.manifest.spec_repo(spec.name)
        has_changed_repo = !previous_spec_repo.nil? &amp;&amp; current_repo &amp;&amp; !current_repo.casecmp(previous_spec_repo).zero?
        title = &quot;Installing #{spec.name} #{spec.version}&quot;
        title &lt;&lt; &quot; (was #{previous_version} and source changed to `#{current_repo}` from `#{previous_spec_repo}`)&quot; if has_changed_version &amp;&amp; has_changed_repo
        title &lt;&lt; &quot; (was #{previous_version})&quot; if has_changed_version &amp;&amp; !has_changed_repo
        title &lt;&lt; &quot; (source changed to `#{current_repo}` from `#{previous_spec_repo}`)&quot; if !has_changed_version &amp;&amp; has_changed_repo
      else
        # 非changed状态
        title = &quot;Installing #{spec}&quot;
      end
      UI.titled_section(title.green, title_options) do
        # 通过name拿到对应的installer，记录到@pod_installer中
        install_source_of_pod(spec.name)
      end
    else
      #如果没有changed情况,则创建一个PodSourceInstaller实例
      UI.section(&quot;Using #{spec}&quot;.red, title_options[:verbose_prefix]) do
        create_pod_installer(spec.name)
      end
    end
  end
end</code></pre>
<p>这个方法主要是根据依赖分析的结果，根据Pod的状态的不同进行不同的处理，如果在<code>pods_to_install</code>里面则安装Pod<code>install_source_of_pod</code>，否则直接走<code>create_pod_installer</code>方法，直接从缓存中取。</p>
<pre><code class="ruby"># 通过缓存返回PodSourceInstaller实例
def create_pod_installer(pod_name)
  specs_by_platform = specs_for_pod(pod_name)

  if specs_by_platform.empty?
    requiring_targets = pod_targets.select { |pt| pt.recursive_dependent_targets.any? { |dt| dt.pod_name == pod_name } }
    message = &quot;Could not install &#39;#{pod_name}&#39; pod&quot;
    message += &quot;, dependended upon by #{requiring_targets.to_sentence}&quot; unless requiring_targets.empty?
    message += &#39;. There is either no platform to build for, or no target to build.&#39;
    raise StandardError, message
  end

  # 通过sandbox，specs的platform信息生成Installer实例
  pod_installer = PodSourceInstaller.new(sandbox, podfile, specs_by_platform, :can_cache =&gt; installation_options.clean?)
  pod_installers &lt;&lt; pod_installer
  pod_installer
end

# 安装Pods,如果resolver声明一个Pod已经安装或者已经存在则将其删除并重新安装
# 如果不存在则直接安装
def install_source_of_pod(pod_name)
  pod_installer = create_pod_installer(pod_name)
  pod_installer.install!
  @installed_specs.concat(pod_installer.specs_by_platform.values.flatten.uniq)
end</code></pre>
<p><code>pod_installer</code>会调用<code>install!</code>方法(pod_source_installer.rb)：</p>
<pre><code class="ruby">def install!
  # 如果未经历过pre-download阶段或者local阶段的Pod，则通过对应的Source下载
  download_source unless predownloaded? || local?
  # 执行Spec 中的Prepar Command
  PodSourcePreparer.new(root_spec, root).prepare! if local?
  sandbox.remove_local_podspec(name) unless predownloaded? || local? || external?
end

def download_source
  verify_source_is_secure(root_spec)
  download_result = Downloader.download(download_request, root, :can_cache =&gt; can_cache?)

  if (specific_source = download_result.checkout_options) &amp;&amp; specific_source != root_spec.source
    sandbox.store_checkout_source(root_spec.name, specific_source)
  end
end</code></pre>
<p>上面的方法主要是将Pod通过对应的source下载下来，会去调用<code>Downloader</code>组件处理所有的下载的逻辑</p>
<h5 id="5-targets-校验"><a href="#5-targets-校验" class="headerlink" title="5. targets 校验"></a>5. targets 校验</h5><p><code>validate_targets</code>过程是用来验证之前流程中的产物Pod所生成的targets的合法性方法。</p>
<pre><code class="ruby">def validate_targets
  validator = Xcode::TargetValidator.new(aggregate_targets, pod_targets, installation_options)
  validator.validate!
end

# target_validator.rb
def validate!
  # 重名检测
  verify_no_duplicate_framework_and_library_names
  # 用来验证动态库是否有静态库或者framework静态库
  verify_no_static_framework_transitive_dependencies
  # 验证Pod中是否指明多个Swift版本，如果有的话需要检测这些依赖是否需要进行build
  verify_swift_pods_swift_version
  # 验证Swift 的Pod是否有module依赖
  verify_swift_pods_have_module_dependencies
  verify_no_multiple_project_names if installation_options.generate_multiple_pod_projects?
end</code></pre>
<p><code>verify_no_static_framework_transitive_dependencies</code>这个方法是用来验证动态库中是否有.a或.framework的静态库，场景：A组件依赖B组件，B组件中通过<code>vendored_libraries</code>方式加载的静态库(.a、.framework)，如果此时在Podfile里面使用了<code>use_framework!</code>,在打包的时候<code>framework</code>会将<code>vendored_libraries</code>中的内容包括进来，这个时候就在符号决议的时候产生冲突，在混合开发的项目里面，动态库中依赖静态库的场景还是很常见的，可以查看这篇组件化的文章：<a href="https://www.valiantcat.cn/index.php/2017/04/24/45.html" target="_blank" rel="noopener">组件化-动态库实战</a>。</p>
<pre><code>The &#39;Pods-xx&#39; target has transitive dependencies that include static binaries: (static_libs.to_sentence)
</code></pre><p>在swift项目中，必须使用<code>use_framework!</code>（目前Cocoapods1.5宣布已经支持Swift使用静态库），因此经常会遇到上述的问题。  </p>
<p>除了文章中这种处理方式，还可以通过修改cocoapods相关的参数达到目的：  </p>
<p>1.修改pod库中的<code>podspec</code>，增加<code>pod_target_xcconfig</code>(表示pod本身被依赖时，修改的编译选项，而user_target_xcconfig表示修改依赖pod的项目的编译选项)</p>
<pre><code class="ruby">s.pod_target_xcconfig = {
    &#39;FRAMEWORK_SEARCH_PATHS&#39; =&gt; &#39;$(inherited) $(PODS_ROOT)/AlipaySDKIniOS&#39;,
    &#39;OTHER_LDFLAGS&#39;          =&gt; &#39;$(inherited) -undefined dynamic_lookup&#39;
}</code></pre>
<p>2.hook    <code>verify_no_static_framework_transitive_dependencies</code>方法，不对动态库依赖静态做检测</p>
<pre><code class="ruby">pre_install do |installer|
    # workaround for https://github.com/CocoaPods/CocoaPods/issues/3289
    def installer.verify_no_static_framework_transitive_dependencies; end
end</code></pre>
<p>特别说明下<code>vendored_libraries</code>是用来在<code>podspec</code>中指定依赖的静态库.a或.framework，如``s.vendored_libraries = ‘libWeiboSDK/libWeiboSDK.a’`。</p>
<h5 id="6-集成"><a href="#6-集成" class="headerlink" title="6. 集成"></a>6. 集成</h5><p> <code>generate_pods_project</code>会把所有的组件通过Project文件的形式组织起啦，并且对Project做一些用户指定的配置。</p>
<pre><code class="ruby">def integrate
  # 生成外层项目
  generate_pods_project
  if installation_options.integrate_targets?
    # 集成用户配置，读取依赖项，使用xcconfig来配置
    integrate_user_project
  else
    UI.section &#39;Skipping User Project Integration&#39;
  end
end

def generate_pods_project
  stage_sandbox(sandbox, pod_targets)

  cache_analysis_result = analyze_project_cache
  pod_targets_to_generate = cache_analysis_result.pod_targets_to_generate
  aggregate_targets_to_generate = cache_analysis_result.aggregate_targets_to_generate

  clean_sandbox(pod_targets_to_generate)

  # 
  create_and_save_projects(pod_targets_to_generate, aggregate_targets_to_generate,
                           cache_analysis_result.build_configurations, cache_analysis_result.project_object_version)
  SandboxDirCleaner.new(sandbox, pod_targets, aggregate_targets).clean!

  update_project_cache(cache_analysis_result, target_installation_results)
end

def integrate_user_project
  UI.section &quot;Integrating client #{&#39;project&#39;.pluralize(aggregate_targets.map(&amp;:user_project_path).uniq.count)}&quot; do

    installation_root = config.installation_root
    integrator = UserProjectIntegrator.new(podfile, sandbox, installation_root, aggregate_targets, generated_aggregate_targets,
                                           :use_input_output_paths =&gt; !installation_options.disable_input_output_paths?)
    integrator.integrate!
  end
end</code></pre>
<p>在<code>~/lib/cocoapods/installer/user_project_integrator.rb</code>文件中的<code>integrate</code>方法：</p>
<pre><code class="ruby">def integrate!
  create_workspace
  deintegrated_projects = deintegrate_removed_targets
  integrate_user_targets
  warn_about_xcconfig_overrides
  projects_to_save = (user_projects_to_integrate + deintegrated_projects).uniq
  save_projects(projects_to_save)
end</code></pre>
<h3 id="pod-install-vs-pod-update"><a href="#pod-install-vs-pod-update" class="headerlink" title="pod install vs pod update"></a>pod install vs pod update</h3><p>在<a href="https://guides.cocoapods.org/using/pod-install-vs-update.html" target="_blank" rel="noopener">cocoapods guides</a> 中对于<code>pod install</code> vs <code>pod update</code>区别的翻译如下：</p>
<p>1.在项目中第一次使用Cocoapods时（即没有<code>Podfile.lock</code>文件的情况），或者在podfile中添加、删除、更新pods时，可使用<code>pod install</code>下载安装pod。</p>
<p>2.<code>pod update [PODNAME]</code>用在需要更新pods的最新版本时</p>
<h4 id="pod-install"><a href="#pod-install" class="headerlink" title="pod install"></a>pod install</h4><p>除了在新建工程时，需用到<code>pod install</code>，在后续执行<code>pod install</code>时，对于已经列在<code>podfile.lock</code>中的pod，它会下载lock锁定的版本，而不会去检查是否有最新的可用版本，对于没有在podfile.lock中文件的库，会根据podfile文件中指定的版本去下载符合指定返回内最新的版本。</p>
<h5 id="pod-update"><a href="#pod-update" class="headerlink" title="pod update"></a>pod update</h5><pre><code class="ruby"># update.rb
installer.repo_update = repo_update?(:default =&gt; true)
installer.update = false

# analyzer.rb
deleted_and_changed += pods_to_update[:pods] if update_mode == :selected</code></pre>
<p><code>pod update [PODNAME]</code>命令，首先会更新本地的spec 仓库，<code>pod install</code>默认的<code>repo_update</code>为<code>false</code>。其次会忽略podfile.lock中的锁定的版本，更新到podfile中指定的版本。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/liututu1213/liututu1213.github.io/blog/6648/2020/01/18/Ruby%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liututu1213">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渣渣程序员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/6648/2020/01/18/Ruby%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Ruby基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-18 00:56:10" itemprop="dateCreated datePublished" datetime="2020-01-18T00:56:10+08:00">2020-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-25 22:30:30" itemprop="dateModified" datetime="2020-05-25T22:30:30+08:00">2020-05-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Ruby/" itemprop="url" rel="index"><span itemprop="name">Ruby</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-Ruby-面向对象概览"><a href="#1-Ruby-面向对象概览" class="headerlink" title="1. Ruby 面向对象概览"></a>1. Ruby 面向对象概览</h3><h4 id="1-1-基础变量"><a href="#1-1-基础变量" class="headerlink" title="1.1 基础变量"></a>1.1 基础变量</h4><pre><code class="ruby">x = 1
y = 1.0

puts x.class
puts y.class</code></pre>
<p>打印结果：</p>
<pre><code>Integer
Float</code></pre><p>在Ruby中，变量可以包含Ruby可以理解的任何概念，==在Ruby中所有的元素，包括基本类型都是对象，这个内置类有定义好的方法来执行数字类的操作==，同时也不存在==运算符==的概念，所谓的<code>1 + 1</code>，其实只不过是<code>1. + (1)</code>的语法糖而已。</p>
<h4 id="1-2-Ruby-对象和类"><a href="#1-2-Ruby-对象和类" class="headerlink" title="1.2 Ruby 对象和类"></a>1.2 Ruby 对象和类</h4><h5 id="1-2-1-对象"><a href="#1-2-1-对象" class="headerlink" title="1.2.1 对象"></a>1.2.1 对象</h5><p>Ruby是一个面向对象的编程语言</p>
<pre><code class="ruby">class Person
    attr_accessor :name, :age, :gender
end

p = Person.new
p.name = &quot;小明&quot;
p.age = 10
p.gender = &quot;woman&quot;

puts &quot;#{ p.name }&quot;</code></pre>
<p><code>attr_accessor</code>创建了三个属性(attributes)，其中accessor表示让这些属性可访问，可被修改和设置，除此之外，还有attr_reader<code>表示只可读，</code>attr_writer`表示只可写入。</p>
<h5 id="1-2-2-继承"><a href="#1-2-2-继承" class="headerlink" title="1.2.2 继承"></a>1.2.2 继承</h5><p>面向对象编程的特点之一就是：继承。</p>
<pre><code class="ruby">class Pet
    attr_accessor :name, :age, :color
end

class Cat &lt;Pet
end

class Dog &lt;Pet
    def bark
        puts &quot;Woof !&quot;
    end
end

class Snake &lt;Pet
    attr_accessor :length
end</code></pre>
<h4 id="1-2-3-Kernel模块的方法"><a href="#1-2-3-Kernel模块的方法" class="headerlink" title="1.2.3 Kernel模块的方法"></a>1.2.3 Kernel模块的方法</h4><p>Kernel是一个特殊的类，前面使用到的<code>puts</code>方法没有完整的类或者对象的前缀，实际上，<code>puts</code>是来自Kernel模块的方法，当调用<code>puts</code>时，Ruby发现没有指定任何类或对象，就在默认的、预定义的类和模块中查到相同名的方法，在Kernel模块中进行查找，并进行调用，也可以显式地调用<code>Kernel.puts &quot;hi&quot;</code>。</p>
<h3 id="2-Ruby的构造元素：数据、表达式和流程控制"><a href="#2-Ruby的构造元素：数据、表达式和流程控制" class="headerlink" title="2. Ruby的构造元素：数据、表达式和流程控制"></a>2. Ruby的构造元素：数据、表达式和流程控制</h3><h4 id="2-1-数字与表达式"><a href="#2-1-数字与表达式" class="headerlink" title="2.1 数字与表达式"></a>2.1 数字与表达式</h4><h5 id="2-1-1-比较运算符和表达式"><a href="#2-1-1-比较运算符和表达式" class="headerlink" title="2.1.1 比较运算符和表达式"></a>2.1.1 比较运算符和表达式</h5><table>
<thead>
<tr>
<th align="center">比较运算</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x &gt;  y</td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center">x &lt; y</td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center">x == y</td>
<td align="center">等于</td>
</tr>
<tr>
<td align="center">x &gt;= y</td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center">x &lt;= y</td>
<td align="center">小于等于</td>
</tr>
<tr>
<td align="center">x &lt;=&gt; y</td>
<td align="center">比较，如果x==y则返回0，x大于y则返回1，如果x小于y则返回-1</td>
</tr>
<tr>
<td align="center">x != y</td>
<td align="center">不等于</td>
</tr>
</tbody></table>
<pre><code class="ruby">x = 10 
y = 3
puts x.to_f / y.to_f

z = 3.845
puts z.to_i
puts z.round

f = 3.9
puts f.floor

c = 10.1
puts c.ceil</code></pre>
<p>打印结果：</p>
<pre><code>3.3333333333333335
3
3.85
3
11</code></pre><p>Ruby中提供函数用于浮点数（Float）和整数（Integer）之间的转换。<code>to_i</code>会直接去掉小数点，<code>round</code>为四舍五入，<code>floor</code>返回比接受者小的最大整数，<code>ceil</code>返回比接受者大的最大整数</p>
<h5 id="2-1-2-常量"><a href="#2-1-2-常量" class="headerlink" title="2.1.2 常量"></a>2.1.2 常量</h5><p>常量在Ruby中的表达形式是以大写字母开头的变量名。</p>
<pre><code class="ruby">Pi = 3.141592
Pi = 3</code></pre>
<p>运行结果：</p>
<pre><code>constant.rb:2: warning: already initialized constant Pi
constant.rb:1: warning: previous definition of Pi was here</code></pre><p>对于常量的值，Ruby提供了完全的控制权，在前面定义的Dog等class 以大写字母开头的名字来引用类，是因为类一旦定义之后，就是程序的固化部分，与常量的性质类似。</p>
<h4 id="2-2-文本与字符串"><a href="#2-2-文本与字符串" class="headerlink" title="2.2 文本与字符串"></a>2.2 文本与字符串</h4><h5 id="2-2-1-字面字符串"><a href="#2-2-1-字面字符串" class="headerlink" title="2.2.1 字面字符串"></a>2.2.1 字面字符串</h5><p>在Ruby中所有的字符串都是String类的对象，<code>&quot;hello&quot;</code>这种构造的字符串称为字面字符串。</p>
<p>把字符串包含在程序中有许多方式，如用引号只适合于单行文本，如果是多行文本则可以使用如下的方式：</p>
<pre><code class="ruby">x = %q{this is string  
of the multi line capabilities}
puts x</code></pre>
<p>在上面的例子中，引号被替换成<code>%q{}</code>,并且也可以用<code>&lt;&gt;</code>、<code>()</code>或其他自选的两个分解符代替引号。</p>
<h5 id="2-2-2-字符串表达式"><a href="#2-2-2-字符串表达式" class="headerlink" title="2.2.2 字符串表达式"></a>2.2.2 字符串表达式</h5><table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">“a” + “b”</td>
<td align="center">“ab”</td>
</tr>
<tr>
<td align="center">“abc” * 2</td>
<td align="center">“abcabc”</td>
</tr>
<tr>
<td align="center">puts “x” &gt; “y”      =&gt; false</td>
<td align="center">大小比较</td>
</tr>
</tbody></table>
<h5 id="2-2-3-字符串-占位符"><a href="#2-2-3-字符串-占位符" class="headerlink" title="2.2.3 字符串 占位符"></a>2.2.3 字符串 占位符</h5><pre><code class="ruby">x = 10
y = 20
puts &quot;#{x} + #{y} = #{x+y}&quot;</code></pre>
<p>插写一段重复的字符串，可以使用以下方式：</p>
<pre><code class="ruby">puts &quot;it&#39;s a #{&quot;bad &quot; * 5} world&quot;</code></pre>
<h5 id="2-2-4-字符串方法"><a href="#2-2-4-字符串方法" class="headerlink" title="2.2.4 字符串方法"></a>2.2.4 字符串方法</h5><p>对字符串”Test”调用不同的方法的结果</p>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">“Test”.capitalize</td>
<td align="center">Test</td>
</tr>
<tr>
<td align="center">puts “Test”.downcase</td>
<td align="center">Test</td>
</tr>
<tr>
<td align="center">“Test”.chop</td>
<td align="center">Tes</td>
</tr>
<tr>
<td align="center">“Test”.hash</td>
<td align="center">3285097822602877765</td>
</tr>
<tr>
<td align="center">“Test”.next</td>
<td align="center">Tesu</td>
</tr>
<tr>
<td align="center">“Test”.reverse</td>
<td align="center">tseT</td>
</tr>
<tr>
<td align="center">“Test”.sum</td>
<td align="center">416</td>
</tr>
<tr>
<td align="center">“Test”.swapcase</td>
<td align="center">tEST</td>
</tr>
<tr>
<td align="center">“Test”.upcase</td>
<td align="center">TEST</td>
</tr>
</tbody></table>
<h5 id="2-2-5-正则表达式与字符操作"><a href="#2-2-5-正则表达式与字符操作" class="headerlink" title="2.2.5 正则表达式与字符操作"></a>2.2.5 正则表达式与字符操作</h5><pre><code class="ruby">puts &quot;foobar&quot;.sub(&quot;bar&quot;, &quot;foo&quot;)</code></pre>
<p><code>sub</code>将第一个参数替换成第二个参数。</p>
<pre><code class="ruby">puts &quot;this is a test string&quot;.gsub(&quot;i&quot;, &quot;&quot;)</code></pre>
<p><code>gsub</code>方法会对所有匹配文本进行多次替换。</p>
<pre><code class="ruby">x = &quot;this is a test&quot;
puts x.sub(/^../, &quot;Hello&quot;)
puts x.sub(/..$/, &quot;Hello&quot;)</code></pre>
<p>运行结果：</p>
<pre><code>Hellois is a test
this is a teHello</code></pre><p>在正则表达式中<code>^</code>，称为锚，表示正则表达式将从字符串中的任一行开头进行匹配，<code>..</code>中每一个点表示”任何字符“，整个表达式表达的是某行开始的开头两个字符，<code>$</code>为另一种锚，表示行尾。</p>
<h4 id="2-3-数组与列表"><a href="#2-3-数组与列表" class="headerlink" title="2.3 数组与列表"></a>2.3 数组与列表</h4><h5 id="2-3-1-基本数组"><a href="#2-3-1-基本数组" class="headerlink" title="2.3.1 基本数组"></a>2.3.1 基本数组</h5><p>在Ruby中，可以用数组(array)来表示对象的有序集合。</p>
<pre><code class="ruby">x = [1, 2, 3, 4]
x[2] = &quot;Fish&quot; * 3
x &lt;&lt; &quot;word&quot;
x.push(5)
puts x</code></pre>
<p>对于数组来说，<code>&lt;&lt;</code>就是把数据放到数组末尾的运算符，也可以调用<code>push</code>,具有相同的效果，<code>x.pop</code>表示一处末尾元素。</p>
<pre><code class="ruby">x = [1, 2, 3, 4]
puts x.join(&quot;,&quot;)</code></pre>
<p><code>join</code>表示把数组元素以指定的字符串连接起来。</p>
<pre><code class="ruby">x = &quot;this is a test&quot;
puts x.split(&quot; &quot;)</code></pre>
<p><code>split</code>表示将字符串以特定的字符串，分割成字符串数组。</p>
<h5 id="2-3-2-数组迭代"><a href="#2-3-2-数组迭代" class="headerlink" title="2.3.2 数组迭代"></a>2.3.2 数组迭代</h5><pre><code class="ruby">x = [1, &quot;test&quot;, 2, 3, 4]
x.each {|element| puts element.to_s + &quot;X&quot;}

y = x.collect {|element| element * 2}
puts y</code></pre>
<p><code>each</code> 方法遍历数组的每个元素，<code>collect</code>方法对数组进行实时转换。</p>
<pre><code class="ruby">x = [1, 2, 3, 4]
y = [1, 2]
z = x + y
puts x.empty?
puts x.first
puts x.last
puts x.reverse.inspect</code></pre>
<p>运行结果：</p>
<pre><code>false
1
4
[4, 3, 2, 1]</code></pre><pre><code class="ruby">x = [1, 2, 3, 4]
y = [1, 2]
z = x + y
puts z.uniq.inspect</code></pre>
<p>打印结果：</p>
<pre><code>[1, 2, 3, 4]</code></pre><p><code>uniq</code>这个方法是用来移除重复的元素。</p>
<h4 id="2-4-散列表"><a href="#2-4-散列表" class="headerlink" title="2.4 散列表"></a>2.4 散列表</h4><p>数组是对象的集合，散列表亦是。散列表中的对象不在列表给定位置，而是给定一个指向对象的键(key)。</p>
<pre><code class="ruby">dictionary = {&#39;cat&#39; =&gt; &#39;feline animal&#39;, &#39;dog&#39; =&gt; &#39;canine animal&#39;}
puts dictionary
puts dictionary.size</code></pre>
<p>运行结果：</p>
<pre><code>{&quot;cat&quot;=&gt;&quot;feline animal&quot;, &quot;dog&quot;=&gt;&quot;canine animal&quot;}
2</code></pre><h5 id="2-4-1-散列表的基础方法"><a href="#2-4-1-散列表的基础方法" class="headerlink" title="2.4.1 散列表的基础方法"></a>2.4.1 散列表的基础方法</h5><p>获取散列表元素信息</p>
<pre><code class="ruby">x = {&#39;a&#39; =&gt; 1, &#39;b&#39; =&gt; 2}
x.each { |key, value|
    puts &quot;#{key} equals #{value}&quot;
}
puts &quot;keys: #{x.keys.inspect} \nvalue: #{x.values.inspect}&quot;</code></pre>
<p>删除元素</p>
<pre><code class="ruby">x = {&#39;a&#39; =&gt; 1, &#39;b&#39; =&gt; 2}
x.delete(&quot;a&quot;)</code></pre>
<p> 有条件地删除元素</p>
<pre><code class="ruby">x = {&#39;a&#39; =&gt; 1, &#39;b&#39; =&gt; 2}
x.delete_if{|key, value| value &lt; 2}
puts x.inspect</code></pre>
<h4 id="2-5-流程控制"><a href="#2-5-流程控制" class="headerlink" title="2.5 流程控制"></a>2.5 流程控制</h4><h5 id="2-5-1-if与unless"><a href="#2-5-1-if与unless" class="headerlink" title="2.5.1 if与unless"></a>2.5.1 if与unless</h5><pre><code class="ruby">age = 10
puts &quot;you are too young to use this system&quot; if age &lt; 18
if age &lt; 18 
    puts &quot;you are too young to use this system&quot; 
end</code></pre>
<p>上面这两种方式功能等同。</p>
<pre><code class="ruby">age = 10
puts &quot;so we are going to exit your program now&quot; unless age &gt; 18</code></pre>
<p><code>unless</code> 是<code>if</code>的反义词。</p>
<h5 id="2-5-2-elsif-与case"><a href="#2-5-2-elsif-与case" class="headerlink" title="2.5.2 elsif 与case"></a>2.5.2 elsif 与case</h5><pre><code class="ruby">color = &quot;orange&quot;
if color == &quot;orange&quot;
    puts &quot;i like this color&quot;
elsif color == &#39;green&#39;
    puts &quot;i not like&quot;
else 
    puts &quot;normal&quot;
end</code></pre>
<p><code>case</code>块首先处理表达式，然后找出匹配该表达式的<code>when</code>块并执行，如果匹配不到<code>when</code>则执行<code>case</code>中的<code>else</code>块</p>
<pre><code class="ruby">case color
when &quot;orange&quot;
    puts &quot;i like this color&quot;
when &quot;green&quot;
    puts &quot;i not like&quot;
else
    puts &quot;normal&quot;    
end</code></pre>
<h5 id="2-5-3-代码块"><a href="#2-5-3-代码块" class="headerlink" title="2.5.3 代码块"></a>2.5.3 代码块</h5><pre><code class="ruby">def each_vowel(&amp;code_block)
    %w{a e i o u}.each { |vowel| code_block.call(vowel)}
end

each_vowel { |vowel|
    puts vowel
}</code></pre>
<p><code>each_vowel</code>接受代码块作为参数，<code>&amp;</code>表示该参数是代码块，<code>call</code>执行传递进来的代码块。</p>
<pre><code class="ruby">def each_vowel(&amp;code_block)
    %w{a e i o u}.each { |vowel| yield vowel}
end</code></pre>
<p><code>yield</code>会自动检测传递给它的代码块，并将控制权移交给该代码块。</p>
<p>ps：一次只能传递一个代码块，任何方法都不可能接受两个及以上的代码块作为参数，但代码块本身可以接受多个参数。</p>
<pre><code class="ruby">print_param = lambda { |x| puts x}
print_param.call(100)</code></pre>
<p>可以用<code>lambda</code>方法把代码块储存在变量中，用lambda对象的<code>call</code>方法来执行代码块，以及接受传递来的任何参数。</p>
<h4 id="2-6-其他构造元素"><a href="#2-6-其他构造元素" class="headerlink" title="2.6 其他构造元素"></a>2.6 其他构造元素</h4><h5 id="2-6-1-日期与时间"><a href="#2-6-1-日期与时间" class="headerlink" title="2.6.1 日期与时间"></a>2.6.1 日期与时间</h5><p>Ruby提供了<code>Time</code>这个类来处理时间和日期，<code>Time</code>内部机制是用微妙值来保存时间，根据UNIX的时间基准：格林尼治标准时间(GMT)/协调世界时(UTC) 1970年元月1日0时0分0秒。</p>
<pre><code class="ruby">puts Time.now</code></pre>
<p>打印结果：</p>
<pre><code>2020-01-28 19:18:51 +0800</code></pre><p><code>+0800</code>表示当前时区的时间 </p>
<pre><code class="ruby">puts Time.local(&quot;2020&quot;, &quot;01&quot;, &quot;27&quot;, &quot;19&quot;, &quot;22&quot;, &quot;00&quot;)</code></pre>
<p><code>Time</code>允许根据当前时区创建一个<code>Time</code>对象，从month开始所有的参数都是可选的。</p>
<pre><code class="ruby">puts Time.utc(&quot;2020&quot;, &quot;01&quot;, &quot;27&quot;, &quot;19&quot;, &quot;22&quot;, &quot;00&quot;)</code></pre>
<p>根据GMT/UTC创建<code>Time</code>对象，所需参数与<code>local</code>方法类似。</p>
<pre><code class="ruby">seconds = Time.now.to_i
time = Time.at(seconds)

puts time
puts time.year, time.month</code></pre>
<p>基准时间和<code>Time</code>对象互转，以及获取日期的年、月等相关属性。</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">方法的返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hour</td>
<td align="center">表示24小时格式的数字</td>
</tr>
<tr>
<td align="center">min</td>
<td align="center">分钟数</td>
</tr>
<tr>
<td align="center">sec</td>
<td align="center">秒数</td>
</tr>
<tr>
<td align="center">usec</td>
<td align="center">微秒数</td>
</tr>
<tr>
<td align="center">day</td>
<td align="center">该月第几天</td>
</tr>
<tr>
<td align="center">mday</td>
<td align="center">与day同义</td>
</tr>
<tr>
<td align="center">wday</td>
<td align="center">按周计的天数</td>
</tr>
<tr>
<td align="center">yday</td>
<td align="center">按年计的天数</td>
</tr>
<tr>
<td align="center">month</td>
<td align="center">当年月份</td>
</tr>
<tr>
<td align="center">year</td>
<td align="center">年份</td>
</tr>
<tr>
<td align="center">zone</td>
<td align="center">返回时间关联的时区名</td>
</tr>
<tr>
<td align="center">utc?</td>
<td align="center">根据time判断是否在UTC/GMT时区</td>
</tr>
<tr>
<td align="center">gmt?</td>
<td align="center">与utc?方法同义</td>
</tr>
</tbody></table>
<h3 id="3-类、对象和模块"><a href="#3-类、对象和模块" class="headerlink" title="3. 类、对象和模块"></a>3. 类、对象和模块</h3><h4 id="3-1-面向对象的基础知识"><a href="#3-1-面向对象的基础知识" class="headerlink" title="3.1 面向对象的基础知识"></a>3.1 面向对象的基础知识</h4><h5 id="3-1-1-局部变量、全局变量、实例变量和类变量"><a href="#3-1-1-局部变量、全局变量、实例变量和类变量" class="headerlink" title="3.1.1 局部变量、全局变量、实例变量和类变量"></a>3.1.1 局部变量、全局变量、实例变量和类变量</h5><p>全局变量在程序的任何地方都可以访问，包括在类或对象中，在Ruby中全局变量并不常用，因为它违背了面向对象的思想，在Ruby使用<code>$</code>符号来定义全局变量。</p>
<pre><code class="ruby">$x = 10
def basic_mehod
    puts $x
end

basic_mehod</code></pre>
<p>实例变量其作用域关联于当前对象，实例变量有一个<code>@</code>符号前缀。</p>
<p>类变量的作用域处于整个类中，类变量以<code>@@</code>符号为前缀表示。</p>
<h5 id="3-1-2-类方法和对象方法"><a href="#3-1-2-类方法和对象方法" class="headerlink" title="3.1.2 类方法和对象方法"></a>3.1.2 类方法和对象方法</h5><pre><code class="ruby">class Square
    def test_method
        puts &quot;from an instance of the class&quot;
    end

    def self.test_method
        puts &quot;from the Square class&quot;
    end
end</code></pre>
<p><code>self.test_method</code>为类方法，类方法由<code>self.</code>前缀标识，或者也可以使用<code>Square.test_method</code>来定义类方法。</p>
<h5 id="3-1-3-继承"><a href="#3-1-3-继承" class="headerlink" title="3.1.3 继承"></a>3.1.3 继承</h5><p>Ruby中任何类都可以继承另一个类的功能特性，Ruby只支持单继承。</p>
<pre><code class="ruby">class Person
    def initialize(name)
        @name = name
    end

    def name
        @name
    end
end

class Doctor &lt; Person
    def name
        &quot;Dr. &quot; + super
    end
end</code></pre>
<p><code>Doctor</code>类覆写<code>name</code>方法，并调用<code>super</code>。</p>
<h5 id="3-1-4-覆写现有方法"><a href="#3-1-4-覆写现有方法" class="headerlink" title="3.1.4 覆写现有方法"></a>3.1.4 覆写现有方法</h5><p>Ruby是一门动态语言，可以覆写现有的类和方法。</p>
<pre><code class="ruby">class String
    def length
        20
    end
end
puts &quot;test string&quot;.length</code></pre>
<p>Ruby的一些程序库和扩展（插件）覆写了核心类的方法，以扩展Ruby的通用功能，对于覆写系统提供的方法，还是要小心慎重。</p>
<h5 id="3-1-5-对象方法的反射和发现"><a href="#3-1-5-对象方法的反射和发现" class="headerlink" title="3.1.5 对象方法的反射和发现"></a>3.1.5 对象方法的反射和发现</h5><p>反射是指计算机程序在运行和使用中，检视、分析并修改自身的过程，而Ruby把这种反射用到了极致，允许在运行自己的代码时，修改语言自身的大部分功能。在Ruby中，可以查询几乎任何对象定义的方法。</p>
<pre><code class="ruby">puts &quot;test&quot;.methods.join(&quot; &quot;)</code></pre>
<p>运行结果：</p>
<pre><code>encode encode! unpack unpack1 include? % * + count partition to_c sum next casecmp casecmp? insert bytesize match match? succ! &lt;=&gt; next! upto index replace == === chr =~ rindex [] []= byteslice getbyte setbyte clear scrub empty? eql? -@ downcase scrub! dump undump upcase +@ capitalize swapcase upcase! downcase! capitalize! swapcase! hex oct freeze inspect bytes chars codepoints lines reverse reverse! concat split crypt ord length size grapheme_clusters succ start_with? center prepend strip rjust rstrip ljust chomp delete_suffix sub to_str to_sym intern sub! lstrip &lt;&lt; to_s to_i to_f gsub! chop! chomp! delete_prefix gsub chop end_with? scan tr strip! lstrip! rstrip! delete_prefix! delete_suffix! delete! tr_s delete squeeze tr! tr_s! each_grapheme_cluster squeeze! each_line each_byte each_char each_codepoint b slice slice! hash encoding force_encoding unicode_normalize valid_encoding? ascii_only? rpartition unicode_normalize! unicode_normalized? to_r between? &lt;= &gt;= clamp &lt; &gt; instance_variable_defined? remove_instance_variable instance_of? kind_of? is_a? tap instance_variable_get instance_variable_set instance_variables singleton_method method public_send define_singleton_method public_method extend to_enum enum_for !~ respond_to? object_id send display nil? class singleton_class clone dup itself yield_self then taint tainted? untaint untrust untrusted? trust frozen? methods singleton_methods protected_methods private_methods public_methods equal? ! __id__ instance_exec != instance_eval __send__</code></pre><p>对于任何对象，methods方法都返回该对象可用方法的数组。</p>
<h5 id="3-1-6-封装"><a href="#3-1-6-封装" class="headerlink" title="3.1.6 封装"></a>3.1.6 封装</h5><p>封装是指对象将其组成数据隐藏在抽象接口之后的能力，封装的基本原理是向类之外尽可能少地减少暴露方法。</p>
<pre><code class="ruby">class Person
    def initialize(name)
        set_name(name)
    end

    def name
        @first_name + &#39; &#39;+ @last_name
    end

    private
    def set_name(name)
        first_name, last_name = name.split(/\s+/)
        set_first_name(first_name)
        set_last_name(last_name)
    end

    def set_first_name(name)
        @first_name = name
    end

    def set_last_name(name)
        @last_name = name
    end
end</code></pre>
<p><code>private</code>关键字的作用就是class之外的代码无法访问，与其他语言的类似。</p>
<pre><code class="ruby">private :set_name, :set_first_name, :set_last_name</code></pre>
<p>也可以把<code>private</code>当成命令使用，向其传递一组符号参数，表示想把这些符号表示的方法设置为私有。</p>
<h5 id="3-1-7-多态"><a href="#3-1-7-多态" class="headerlink" title="3.1.7 多态"></a>3.1.7 多态</h5><p>多态的概念是指编写代码可以同时适用于多种类型和类的对象，如 <code>+</code>方法适用于数据相加、字符串相连以及数组合并等，<code>+</code>方法具体操作什么，完全依赖于具体类型。</p>
<h5 id="3-1-8-嵌套类"><a href="#3-1-8-嵌套类" class="headerlink" title="3.1.8 嵌套类"></a>3.1.8 嵌套类</h5><p>在Ruby中，可以把类放入其他类中，这样的类称为嵌套(nested)类。</p>
<pre><code class="ruby">class Drawing
    def self.get_circle
        Circle.new
    end

    class Line
    end

    class Circle
        def desc
            &quot;this is a circle&quot;
        end
    end
end

d = Drawing.get_circle
c = Drawing::Circle.new

puts d.desc
puts c.desc</code></pre>
<p>嵌套类只能以<code>::</code>的形式创建。</p>
<h5 id="3-1-8-常量的作用域"><a href="#3-1-8-常量的作用域" class="headerlink" title="3.1.8 常量的作用域"></a>3.1.8 常量的作用域</h5><pre><code class="ruby">Pi = 3.141592
class Planet
    Pi = 3.14
    def circle(radius)
        2 * Pi * radius
    end
end
puts Planet::Pi
puts Pi</code></pre>
<p>在类中定义的常量，其作用域在类的环境中，通过<code>Planet::Pi</code>方式调用。</p>
<h5 id="3-1-9-判断对象的类型"><a href="#3-1-9-判断对象的类型" class="headerlink" title="3.1.9 判断对象的类型"></a>3.1.9 判断对象的类型</h5><pre><code class="ruby">puts &quot;hello&quot;.is_a? Object
puts &quot;hello&quot;.kind_of? Object
puts &quot;hello&quot;.instance_of?Object
puts &quot;hello&quot;.instance_of? String</code></pre>
<p>打印结果：</p>
<pre><code>true
true
false
true</code></pre><p><code>is_a?</code>和<code>kind_of?</code>是同义的，<code>instance_of?</code>与这个两个不同的是，只在对象是那个类的实例而不是子类时才返回true。</p>
<h4 id="3-2-模块、命名空间和渗入"><a href="#3-2-模块、命名空间和渗入" class="headerlink" title="3.2 模块、命名空间和渗入"></a>3.2 模块、命名空间和渗入</h4><p>模块提供了一种结构，用来把Ruby类、方法和常量收集到单独命名和定义的单元中，这样可以避免与现有类、方法和常量发生命名冲突。</p>
<h5 id="3-2-1-命名空间"><a href="#3-2-1-命名空间" class="headerlink" title="3.2.1 命名空间"></a>3.2.1 命名空间</h5><p>在number_stuff.rb和letter_stuff.rb分别分别存在<code>random</code>方法如下：</p>
<pre><code class="ruby"># number_stuff.rb
def random
    rand(100)
end</code></pre>
<pre><code class="ruby"># letter_stuff.rb
def random
    (rand(26) + 65).chr
end</code></pre>
<p>遇到如下的场景，加载的两个文件都存在同一个方法<code>random</code>:</p>
<pre><code class="ruby">require &#39;./number_stuff.rb&#39;
require &#39;./letter_stuff.rb&#39;

puts random</code></pre>
<p>打印结果:</p>
<pre><code>M</code></pre><p>由于最后一个文件(letter_stuff.rb)被载入，因此结果时使用最后一个版本的<code>random</code>方法。</p>
<pre><code class="ruby">module NumberStuff
    def NumberStuff.random
        rand(100)
    end
end

module LetterStuff
    def LetterStuff.random
        (rand(26) + 65).chr
    end
end</code></pre>
<p>可以用<code>module</code>来解决命名冲突的问题，它提供了命名空间。</p>
<h5 id="3-2-2-渗入"><a href="#3-2-2-渗入" class="headerlink" title="3.2.2 渗入"></a>3.2.2 渗入</h5><p>在Ruby中不支持多继承，但在某些情况，需要从不同的类中共享功能，类似swift中的协议，在这种意义上，模块像某种“超级”类，可被包含到其他类中，用模块提供的功能来扩展其他类。</p>
<pre><code class="ruby">module UsefulFeatures
    def class_name
        self.class.to_s
    end
end

class Person
    include UsefulFeatures

end

p = Person.new
puts p.class_name</code></pre>
<p><code>UsefulFeatures</code>模块看起来几乎像个“类”，不过模块本身就是组织工具，而不是类，<code>class_name</code>方法位于模块中，因此随即被包含在<code>Person</code>类中。<code>include</code>命名是把模块的内容放到当前作用域中。</p>
<pre><code class="ruby">module A
    def a1
        puts &quot;this is a1&quot;
    end
end

module B
    def b1
        puts &quot;this is b1&quot;
    end
end

class Sample
    include A
    include B
    def s1
        puts &quot;this is Sample&quot;
    end
end

s = Sample.new
s.a1
s.b1
s.s1</code></pre>
<p>打印结果：</p>
<pre><code>this is a1
this is b1
this is Sample</code></pre><p>前面提到的<code>Kernel</code>模块包含所有的标准命令，在Ruby中无须指定对象或者类，如<code>load</code>、<code>require</code>、<code>exit</code>等，它们是特殊的方法，通过<code>Kernel</code>模块，被默认包含所有类（包括主程序作用）中。</p>
<p>除了<code>Kernel</code>模块，系统还提供了<code>Enmerable</code>、<code>Comparable</code>模块，<code>Enmerable</code>提供的主要是与迭代瞎相关的功能，如<code>each</code>、<code>sort</code>、<code>max</code>、<code>min</code>等，<code>Comparable</code>为其他类提供比较运算符。</p>
<h3 id="4-部署Ruby应用和程序库"><a href="#4-部署Ruby应用和程序库" class="headerlink" title="4. 部署Ruby应用和程序库"></a>4. 部署Ruby应用和程序库</h3><h4 id="4-1-Ruby程序发布"><a href="#4-1-Ruby程序发布" class="headerlink" title="4.1 Ruby程序发布"></a>4.1 Ruby程序发布</h4><h4 id="4-2-检测Ruby运行环境"><a href="#4-2-检测Ruby运行环境" class="headerlink" title="4.2 检测Ruby运行环境"></a>4.2 检测Ruby运行环境</h4><h4 id="4-3-以gem包形式发布Ruby程序库"><a href="#4-3-以gem包形式发布Ruby程序库" class="headerlink" title="4.3 以gem包形式发布Ruby程序库"></a>4.3 以gem包形式发布Ruby程序库</h4><h3 id="5-Ruby的高级功能"><a href="#5-Ruby的高级功能" class="headerlink" title="5. Ruby的高级功能"></a>5. Ruby的高级功能</h3><h4 id="5-1-动态代码执行"><a href="#5-1-动态代码执行" class="headerlink" title="5.1 动态代码执行"></a>5.1 动态代码执行</h4><h4 id="5-2-Ruby运行其他程序"><a href="#5-2-Ruby运行其他程序" class="headerlink" title="5.2 Ruby运行其他程序"></a>5.2 Ruby运行其他程序</h4><h3 id="6-Ruby-on-Rails-Ruby的杀手级应用"><a href="#6-Ruby-on-Rails-Ruby的杀手级应用" class="headerlink" title="6. Ruby on Rails: Ruby的杀手级应用"></a>6. Ruby on Rails: Ruby的杀手级应用</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/liututu1213/liututu1213.github.io/blog/1442/2020/01/05/Date/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liututu1213">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渣渣程序员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/1442/2020/01/05/Date/" class="post-title-link" itemprop="url">Date</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-05 00:05:39" itemprop="dateCreated datePublished" datetime="2020-01-05T00:05:39+08:00">2020-01-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-25 22:30:30" itemprop="dateModified" datetime="2020-05-25T22:30:30+08:00">2020-05-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/swift/" itemprop="url" rel="index"><span itemprop="name">swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-UTC、GMT和时间戳介绍"><a href="#1-UTC、GMT和时间戳介绍" class="headerlink" title="1. UTC、GMT和时间戳介绍"></a>1. UTC、GMT和时间戳介绍</h4><h5 id="GMT"><a href="#GMT" class="headerlink" title="GMT"></a>GMT</h5><p>格林尼治标准时间（Greenwich Mean Time）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，即本初子午线时间。</p>
<p>由于地球在椭圆轨道里的运动速度不均匀，这个时刻可能与实际的太阳时有误差，所以有了UTC时间出现。</p>
<h5 id="UTC"><a href="#UTC" class="headerlink" title="UTC"></a>UTC</h5><p>协调世界时间（又称世界标准时间），与GMT一样都是本初子午时间，只不过UTC是经过协调后的世界时间，比GMT更加准确。全球一共有24个时区。</p>
<p><img src="https://raw.githubusercontent.com/CathyLy/imageForSource/master/2020/timezone.png" alt="timezone"></p>
<p>而北京时间位于东八区，与格林尼治时间相差八小时，也就是我们经常在开发中遇到8小时时差的问题。</p>
<h4 id="2-swift中Date与Calender关系"><a href="#2-swift中Date与Calender关系" class="headerlink" title="2. swift中Date与Calender关系"></a>2. swift中Date与Calender关系</h4><p><img src="https://raw.githubusercontent.com/liututu1213/imageForSource/master/2020/date-calender.png" alt=""></p>
<p>首先Date可以通过DateFormatter进行互转，Date通过格式化可以转化成自定义的样式，反过来同样成立。在iOS中，没办法像其他语言一样直接time.year这样的api获取年份等信息，想要获取Date的年月日信息需要使用Calende+DateCompontents来完成，反之，也可以通过DateComponents对各个组件进行组装，通过Calender对象变成date。</p>
<p>Calender封装了有关计算时间的系统的信息，其中定义了年的开始、长度和分割，提供了关于日历的信息和日历计算的支持。</p>
<h4 id="3-Date"><a href="#3-Date" class="headerlink" title="3. Date"></a>3. Date</h4><p>iOS中的Date是用来表示公历的GMT时间，Date是没有存储时区等信息，所以不管你在哪个时区打印的Date()都是一样的，这一点非常重要。</p>
<pre><code class="swift">let date = Date()
print(date)</code></pre>
<p>打印结果：</p>
<pre><code>2020-01-04 10:03:01 +0000</code></pre><p>Date()获取的是零时区的时间(格林尼治的时间)，而如果你系统所在的时区是东八区即北京时间，则实际系统时间与打印出来的时间相差八小时。</p>
<p>Date的初始化方法：</p>
<pre><code class="Swift">public init()
public init(timeIntervalSinceNow: TimeInterval) //以当前时间的偏移秒数来初始化
public init(timeIntervalSince1970: TimeInterval) //以GMT时间的偏移秒数来初始化
public init(timeInterval: TimeInterval, since date: Date) //以给定秒数返回相对于另一个给定日期初始化的“日期”
...</code></pre>
<p>时间比较相关方法：</p>
<pre><code class="Swift">public func compare(_ other: Date) -&gt; ComparisonResult
public static func == (lhs: Date, rhs: Date) -&gt; Bool
public static func &lt; (lhs: Date, rhs: Date) -&gt; Bool
public static func &gt; (lhs: Date, rhs: Date) -&gt; Bool
public static func + (lhs: Date, rhs: TimeInterval) -&gt; Date
...</code></pre>
<h5 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h5><p>时间戳是指1970-01-01 00:00:00到当前时间的秒数。</p>
<pre><code>date.timeIntervalSince1970 
date.timeIntervalSinceNow
date.timeIntervalSince(xx)</code></pre><h4 id="4-DateFormatter-Date-与String-互相转换"><a href="#4-DateFormatter-Date-与String-互相转换" class="headerlink" title="4. DateFormatter: Date 与String 互相转换"></a>4. DateFormatter: Date 与String 互相转换</h4><p>DateFormatter 是Formatter的子类，Formatter是将数据在字符串与特定类型的对象之间转换，目前Formatter有两个子类NumberFormatter和DateFormatter。</p>
<p>DateFormatter用来在日期和字符串之间的转换，DateFormatter格式其实是遵守了Unicode Technical Standard。</p>
<pre><code class="swift">open var dateFormat: String!
open var dateStyle: DateFormatter.Style
open var timeStyle: DateFormatter.Style
open var locale: Locale!
open var timeZone: TimeZone!
open var calendar: Calendar! //如果未指定则使用当前用户的逻辑日历</code></pre>
<p>下面将会来一一介绍这些相关的属性。</p>
<p>DateFormatter提供了许多定义好的时间格式，如dateStyle和timeStyle。</p>
<pre><code class="swift">public enum Style : UInt {
    case none
    case short
    case medium
    case long
    case full
}</code></pre>
<table>
<thead>
<tr>
<th align="center">格式类型</th>
<th align="center">dateStyle</th>
<th align="center">timeStyle</th>
</tr>
</thead>
<tbody><tr>
<td align="center">none</td>
<td align="center">/</td>
<td align="center">/</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">1/4/20</td>
<td align="center">7:37 PM</td>
</tr>
<tr>
<td align="center">medium</td>
<td align="center">Jan 4, 2020</td>
<td align="center">7:38:51 PM</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">January 4, 2020</td>
<td align="center">7:39:50 PM GMT+8</td>
</tr>
<tr>
<td align="center">full</td>
<td align="center">Saturday, January 4, 2020</td>
<td align="center">7:40:40 PM China Standard Time</td>
</tr>
</tbody></table>
<p>DateFormatter有一个local的属性，Local是与国际化相关的基础类。</p>
<h4 id="5-Local"><a href="#5-Local" class="headerlink" title="5. Local"></a>5. Local</h4><p>Local是是与国际化相关的基础类，在OS X中，可以到”系统偏好设置-&gt;语言与地区”中设置当前的local。Local是包含所有地区的语言与文化习俗的基础类，一个Local实例包含了针对这个地区内特定一群人的所有语言文化基准，其中包括：</p>
<ul>
<li>语言</li>
<li>键盘</li>
<li>数字、日期和时间格式</li>
<li>货币  如USD</li>
<li>排序和分类</li>
<li>符号、颜色与头像的使用</li>
</ul>
<p>每一个Local的实例对应着一个地区标识符，如en_US、zh_CN等，这些标识符包含 语言码(en)和地区码(US)。</p>
<pre><code class="swift">Locale.preferredLanguages //返回用户偏好设置的语言列表</code></pre>
<h4 id="6-TimeZone"><a href="#6-TimeZone" class="headerlink" title="6. TimeZone"></a>6. TimeZone</h4><p>TimeZone表示时区信息，上面提到过世界上有24是个时区，任何时区都是GMT为基准，TimeZone对象所代表的时区都是相对于GMT的。</p>
<pre><code class="swift">public static var current: TimeZone { get }
public init?(identifier: String) //用给定的标识符初始化timeZone对象
public init?(secondsFromGMT seconds: Int) //通过相对于GMT时间偏移量(时差)来获取时区</code></pre>
<p>一般应用程序的默认时区，是和手机系统设置的时区一致的。</p>
<pre><code>TimeZone.current</code></pre><p>打印结果如下：</p>
<pre><code>▿ Asia/Shanghai (current)
  - identifier : &quot;Asia/Shanghai&quot;
  - kind : &quot;current&quot;
  ▿ abbreviation : Optional&lt;String&gt;
    - some : &quot;GMT+8&quot;
  - secondsFromGMT : 28800 //相对于GMT的时差 秒
  - isDaylightSavingTime : false</code></pre><h4 id="7-DateComponents"><a href="#7-DateComponents" class="headerlink" title="7. DateComponents"></a>7. DateComponents</h4><p>这个类可用于计算未来或过去的日期，Calender用它来实现Date和DateComponents相互转换</p>
<h4 id="8-Calendar"><a href="#8-Calendar" class="headerlink" title="8. Calendar"></a>8. Calendar</h4><p>在iOS中，没办法像其他语言一样直接time.year这样的api获取年份等信息，想要获取Date的年月日需要使用Calender的日历对象。Calender封装了有关计算时间的系统的信息，其中定义了年的开始、长度和分割，提供了关于日历的信息和日历计算的支持。</p>
<pre><code class="swift">public static var current: Calendar { get }
public static var autoupdatingCurrent: Calendar { get } //当前系统设置的日历的值
public init(identifier: Calendar.Identifier) //Identifier 是一个枚举，提供了各种类型的日历
public func component(_ component: Calendar.Component, from date: Date) -&gt; Int //返回一个给定date的日期组件</code></pre>
<p>先来介绍Calender的相关的api</p>
<h5 id="8-1-Calendar-Identifier"><a href="#8-1-Calendar-Identifier" class="headerlink" title="8.1  Calendar.Identifier"></a>8.1  Calendar.Identifier</h5><pre><code class="swift">public enum Identifier {
    case gregorian //公历 Calender的默认值
    case buddhist
    case chinese //农历
    case coptic
    case ethiopicAmeteMihret
    case ethiopicAmeteAlem
    case hebrew
    case iso8601
    case indian
    case islamic
    case islamicCivil
    case japanese
    case persian
    case republicOfChina
}</code></pre>
<h5 id="8-2-Calendar-Component"><a href="#8-2-Calendar-Component" class="headerlink" title="8.2 Calendar.Component"></a>8.2 Calendar.Component</h5><pre><code class="swift">public enum Component {
    case era // 特定时期的时代，取决于日期的日历系统
    case year
    case month
    case day
    case hour
    case minute
    case second
    case weekday //星期几，默认情况下周日为1，周一为2，以此类推
    case weekdayOrdinal //表示指定日期是当前这个月的第几个星期几，如2020-02-13，星期四，是这个月的第2个星期四
    case quarter //返回季度单位的数字，但不同地区季度的起始时间不同，因此此属性默认是0，除非赋值。
    case weekOfMonth //Identifier for the week of the month calendar unit.
    case weekOfYear// Identifier for the week of the year unit.
    case yearForWeekOfYear //Identifier for the week-counting year unit.
    case nanosecond
    case calendar
    case timeZone
}</code></pre>
<p>Date类是无法单独来获取每一个元素的信息，必须使用component方法获取给定日期的日期组件即Calendar.Component，获取某个时间点对应的”年”、”月”、”日”、”第几周”、”周几”等信息。</p>
<h5 id="8-3-Calender相关函数"><a href="#8-3-Calender相关函数" class="headerlink" title="8.3 Calender相关函数"></a>8.3 Calender相关函数</h5><p><code>public func minimumRange(of component: Calendar.Component) -&gt; Range&lt;Int&gt;?</code></p>
<pre><code class="swift">let calendar = Calendar.current
let range = calendar.minimumRange(of: .day)
print(range) //Range(1..&lt;29)</code></pre>
<p>返回指定组件最小的限制范围，如Day Components 最小的范围是1-28</p>
<p><code>public func maximumRange(of component: Calendar.Component) -&gt; Range&lt;Int&gt;?</code></p>
<pre><code class="swift">let calendar = Calendar.current
let range = calendar.maximumRange(of: .day)
print(range) // Range(1..&lt;32)</code></pre>
<p>date所在的小组件在 大组件里的范围。</p>
<p><code>public func range(of smaller: Calendar.Component, in larger: Calendar.Component, for date: Date) -&gt; Range&lt;Int&gt;?</code></p>
<pre><code class="swift">let date = Date() ///&quot;Feb 14, 2020 at 1:10 AM&quot;
let calendar = Calendar.current
let range = calendar.range(of: .day, in: .month, for: date)
print(range) /// Range(1..&lt;30)</code></pre>
<p>返回指定日期所在的小组件在大组件的一个时间范围。</p>
<p><code>public func dateInterval(of component: Calendar.Component, start: inout Date, interval: inout TimeInterval, for date: Date) -&gt; Bool</code></p>
<pre><code class="swift">let date = Date() ///Feb 14, 2020 at 1:14 AM
let calendar = Calendar.current
var d: Date = Date()
var time: Double = 0

/// 当前时间所在的一周的开始时间，周日为每周的开始时间
calendar.dateInterval(of: .weekOfMonth, start: &amp;d, interval: &amp;time, for: date)
print(d)
print(time)</code></pre>
<p>打印结果：</p>
<pre><code>2020-02-08 16:00:00 +0000
604800.0</code></pre><p>通过两个inout参数返回包含给定日期、组件的开始时间和时间长。</p>
<p><code>public func ordinality(of smaller: Calendar.Component, in larger: Calendar.Component, for date: Date) -&gt; Int?</code></p>
<p> 返回指定的日期 指定的较小日历组件(Day)在较大日历组件(weekOfMonth) 的序号。</p>
<p><code>public func date(byAdding components: DateComponents, to date: Date, wrappingComponents: Bool = false) -&gt; Date?</code></p>
<pre><code class="swift">let date = Date() ///2020-02-13 17:29:35 +0000
let calendar = Calendar.current
var dateComponets = DateComponents()
dateComponets.day = 18
let day = calendar.date(byAdding: dateComponets, to: date)!
print(day) 2020-03-02 17:29:35 +0000

let day2 = calendar.date(byAdding: dateComponets, to: date, wrappingComponents: true)!
print(day2) ///2020-02-02 17:29:35 +0000</code></pre>
<p>向给定日期添加组件计算出新的日期，其中<code>wrappingComponents</code>为true表示组件在增加的时候溢出时，不是向更高的组件”进位”</p>
<p><code>public func date(from components: DateComponents) -&gt; Date?</code></p>
<p>用指定的DateComponents创建一个新的日期，如果匹配不到组件的日期，则返回nil。</p>
<pre><code class="swift">public func dateComponents(_ components: Set&lt;Calendar.Component&gt;, from date: Date) -&gt; DateComponents
public func dateComponents(in timeZone: TimeZone, from date: Date) -&gt; DateComponent</code></pre>
<p>返回这个日历时区所有的日历组件，第一个是传入指定的Calendar.Component数组，第二个是传入TimeZone</p>
<pre><code class="swift">public func dateComponents(_ components: Set&lt;Calendar.Component&gt;, from start: Date, to end: Date) -&gt; DateComponents

public func dateComponents(_ components: Set&lt;Calendar.Component&gt;, from start: DateComponents, to end: DateComponents) -&gt; DateComponents</code></pre>
<pre><code>public func component(_ component: Calendar.Component, from date: Date) -&gt; Int</code></pre><pre><code class="swift">let date = Date() //2020-02-15 07:14:06 +0000
let calendar = Calendar.current
let startOfDay = calendar.startOfDay(for: date)
print(startOfDay) //2020-02-14 16:00:00 +0000</code></pre>
<p>返回给定日期的第一个时刻。</p>
<pre><code class="swift">public func compare(_ date1: Date, to date2: Date, toGranularity component: Calendar.Component) -&gt; ComparisonResult
public func isDate(_ date1: Date, equalTo date2: Date, toGranularity component: Calendar.Component) -&gt; Bool </code></pre>
<p>component用于比较的粒度，如.hour 判断两个日期是否在相同的小时内。</p>
<pre><code class="swift">public func isDate(_ date1: Date, inSameDayAs date2: Date) -&gt; Bool
public func isDateInToday(_ date: Date) -&gt; Bool
public func isDateInYesterday(_ date: Date) -&gt; Bool
public func isDateInTomorrow(_ date: Date) -&gt; Bool
public func isDateInWeekend(_ date: Date) -&gt; Bool</code></pre>
<pre><code>public func dateIntervalOfWeekend(containing date: Date) -&gt; DateInterval?</code></pre><p>使用Calender和Components对Date进行的扩展：</p>
<pre><code class="swift">extension Date {
     var startOfWeek: Date {
        var calendar = Calendar.current
        let component = calendar.dateComponents([.yearForWeekOfYear, .weekOfYear, .hour], from: self)
        calendar.firstWeekday = 2
        return calendar.date(from: component)!
    }

    var startOfCurrentMonth: Date {
         let calendar = NSCalendar.current
         let components = calendar.dateComponents([.year, .month, .hour], from: self)
         let startOfMonth = calendar.date(from: components)!
         return startOfMonth
     }
}</code></pre>
<p>startOfWeek获取一周开始的日期，<code>calendar.firstWeekday = 2</code>用于设置一周从周一开始算起；startOfCurrentMonth获取当前日期所在的月开始时间。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/liututu1213/liututu1213.github.io/blog/4809/2019/12/31/PromiseKit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liututu1213">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="渣渣程序员">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/4809/2019/12/31/PromiseKit/" class="post-title-link" itemprop="url">PromiseKit</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-31 01:01:25" itemprop="dateCreated datePublished" datetime="2019-12-31T01:01:25+08:00">2019-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-25 22:30:30" itemprop="dateModified" datetime="2020-05-25T22:30:30+08:00">2020-05-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/swift/" itemprop="url" rel="index"><span itemprop="name">swift</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="Promise中的swift用法"><a href="#Promise中的swift用法" class="headerlink" title="Promise中的swift用法"></a>Promise中的swift用法</h4><h5 id="使用type-inference推导泛型参数"><a href="#使用type-inference推导泛型参数" class="headerlink" title="使用type inference推导泛型参数"></a>使用type inference推导泛型参数</h5><pre><code class="swift">public final class Promise&lt;T&gt;: Thenable, CatchMixin {
  public init&lt;U: Thenable&gt;(_ bridge: U) where U.T == T {
    box = EmptyBox()
    bridge.pipe(to: box.seal)
  }
}</code></pre>
<pre><code class="swift">class EmptyBox&lt;T&gt;: Box&lt;T&gt; {}</code></pre>
<p>在Promise.swift中，<code>EmptyBox</code>是一个泛型类，<code>init</code>方法创建<code>EmptyBox</code>的实例的时候，没有指定类型参数。</p>
<p>对于<code>EmptyBox&lt;T&gt;</code>中的<code>T</code>具体是依据Promise中对于box这个属性的定义：</p>
<pre><code class="swift">let box: Box&lt;Result&lt;T&gt;&gt;</code></pre>
<p>有了这个定义，则可以通过<code>EmptyBox()</code>这样的表达式通过编译，type inference 就会自动把EmptyBox的泛型参数推导为Result&lt;T&gt;。</p>
<p>在某些泛型代码里，面对type inference 推导出来的类型，可以用更为简洁的方式调用init，如<a href="https://github.com/mxcl/PromiseKit/blob/master/Sources/Box.swift">Box.swift</a>  中的用法：</p>
<pre><code class="swift">enum Sealant&lt;R&gt; {
    case pending(Handlers&lt;R&gt;)
    case resolved(R)
}

final class Handlers&lt;R&gt; {
    var bodies: [(R) -&gt; Void] = []
    func append(_ item: @escaping(R) -&gt; Void) { bodies.append(item) }
}

class EmptyBox&lt;T&gt;: Box&lt;T&gt; {
    private var sealant = Sealant&lt;T&gt;.pending(.init())
}</code></pre>
<p><code>Sealant&lt;T&gt;.pending</code>创建一个enum对象，case pending有一个关联值，<code>Handlers&lt;R&gt;</code>，由于Handlers有默认的init的方法，可以先依靠type inference推断出<code>.pending()</code>里需要的参数类型。</p>
<pre><code class="swift">//等价
private var sealant = Sealant&lt;T&gt;.pending(.init())
private var sealant = Sealant&lt;T&gt;.pending(Handlers.init())</code></pre>
<p><code>Sealant</code>和<code>Handlers</code>在Promise中算是原子类型，其中<code>Handlers</code>用于保存处理Promise结果的<code>Handlers</code>，泛型参数R表示Promise的结果，在Handlers的定义中的<code>bodies</code>保存了所有对这个结果感兴趣的方法，在Promise的范式里，新的closure会经过一些列方法，最红由append方法加入到bodies。</p>
<p><code>Sealant</code>可以理解为Promise状态的类型，它的泛型参数<code>R</code>和关联值<code>Handlers</code>中的<code>R</code>是表示相同的含义，都是表示Promise的结果。当一个Promise还在等待结果的时候状态则为<code>.pending</code>，它的关联值就是所有对这个结果有所期待的handlers，如果Promise被满足，状态则改变为<code>.resolved</code>，此时的关联值就包含了Promise期望的值。</p>
<h4 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box</h4><p>在Box的继承体系中，一共有三个类：</p>
<pre><code class="swift">class Box&lt;T&gt; {}
final class SealedBox&lt;T&gt;: Box&lt;T&gt; {}
class EmptyBox&lt;T&gt;: Box&lt;T&gt; {}</code></pre>
<pre><code class="swift">class Box&lt;T&gt; {
    func inspect() -&gt; Sealant&lt;T&gt; { fatalError() }
    func inspect(_: (Sealant&lt;T&gt;) -&gt; Void) { fatalError() }
    func seal(_: T) {}
}</code></pre>
<p><code>Box&lt;T&gt;</code>更像是一个protocol</p>
<ul>
<li><code>inspect() -&gt; Sealant&lt;T&gt;</code>,利用它查询当前Box的状态<code>.pending</code>or<code>.resolved</code></li>
<li><code>inspect(_: (Sealant&lt;T&gt;) -&gt; Void)</code>这个方法完成操作，会根据它的closure参数中<code>Sealant&lt;T&gt;</code>的值的不同而不同</li>
<li><code>seal(_: T</code>用于向Box中封装值，利用这个方法，可以把box的状态从<code>.pending</code>改为<code>.resolved</code></li>
</ul>
<h4 id="SealedBox"><a href="#SealedBox" class="headerlink" title="SealedBox"></a>SealedBox</h4><p>SealedBox表示已经密封好的盒子，指的是状态已经为<code>.resolved</code>，其中已经包含了Promise的结果，且无法再对其进行修改。</p>
<pre><code class="swift">final class SealedBox&lt;T&gt;: Box&lt;T&gt; {
    let value: T

    init(value: T) {
        self.value = value
    }

    override func inspect() -&gt; Sealant&lt;T&gt; {
        return .resolved(value)
    }
}</code></pre>
<p>创建SealedBox时会直接传递一个value，表示把value密封在Box里，它唯一重写的方法<code>inspect</code>就是读取Box的状态，这个方法直接返回<code>.resolved(value)</code>。</p>
<h4 id="EmptyBox"><a href="#EmptyBox" class="headerlink" title="EmptyBox"></a>EmptyBox</h4><p>EmptyBox空的盒子，表示等待往里面装入值，PromiseKit中大部分的功能的实现都是使用EmptyBox来实现的。</p>
<pre><code class="swift">class EmptyBox&lt;T&gt;: Box&lt;T&gt; {
    private var sealant = Sealant&lt;T&gt;.pending(.init()) //可以理解为盒子的封条
    private let barrier = DispatchQueue(label: &quot;org.promisekit.barrier&quot;, attributes: .concurrent)
}</code></pre>
<p>  EmptyBox对Box的三个方法进行了重写:</p>
<pre><code class="swift">override func inspect() -&gt; Sealant&lt;T&gt; {
    var rv: Sealant&lt;T&gt;!
    barrier.sync {
        rv = self.sealant
    }
    return rv
}</code></pre>
<p>第一个方法是获取盒子状态的inspect，用同步的方式获取当前的sealant。</p>
<pre><code class="swift">override func inspect(_ body: (Sealant&lt;T&gt;) -&gt; Void) {
    var sealed = false
    barrier.sync(flags: .barrier) {
        switch sealant {
        case .pending:
            // body will append to handlers, so we must stay barrier’d
            body(sealant)
        case .resolved:
            sealed = true
        }
    }
    if sealed {
        // we do this outside the barrier to prevent potential deadlocks
        // it&#39;s safe because we never transition away from this state
        body(sealant)
    }
}
</code></pre>
<p>第二个inspect方法是主要是把盒子的状态传递给body。</p>
<pre><code class="swift">override func seal(_ value: T) {
    var handlers: Handlers&lt;T&gt;!
    barrier.sync(flags: .barrier) {
        guard case .pending(let _handlers) = self.sealant else {
            return  // already fulfilled!
        }
        handlers = _handlers
        self.sealant = .resolved(value)
    }

    if let handlers = handlers {
        handlers.bodies.forEach{ $0(value) }
    }
}</code></pre>
<p><code>seal</code>这个方法主要的作用：</p>
<ul>
<li>将盒子的状态从<code>.pending</code>编程<code>.resolved</code></li>
<li>把盒子中包含的值变成<code>value</code></li>
<li>通知之前注册过的关注这个变化的handlers</li>
</ul>
<p>在seal的实现里面<code>barrier.sync</code>的作用是只有当盒子的状态还是<code>.pending</code>，才可以执行密封的动作，如果盒子已经被密封上，则直接顺序调用所有的handlers。</p>
<h4 id="Resolver"><a href="#Resolver" class="headerlink" title="Resolver"></a>Resolver</h4><pre><code class="swift">/// An object for resolving promises
public final class Resolver&lt;T&gt; {
    let box: Box&lt;Result&lt;T&gt;&gt;

    init(_ box: Box&lt;Result&lt;T&gt;&gt;) {
        self.box = box
    }

    deinit {
        if case .pending = box.inspect() {
            conf.logHandler(.pendingPromiseDeallocated)
        }
    }
}</code></pre>
<p><code>Resolver</code>包含了<code>Box</code>对象，而Box里面封装的是<code>Result&lt;T&gt;</code>，创建Promise的时候，我们用<code>fulfill</code>方法，向盒子里封装的，就是<code>case fulfill</code>。而使用<code>reject</code>，封装的就是<code>case rejected</code>。</p>
<pre><code class="swift">public extension Resolver {
    /// Fulfills the promise with the provided value
    func fulfill(_ value: T) {
        box.seal(.fulfilled(value))
    }

    /// Rejects the promise with the provided error
    func reject(_ error: Error) {
        box.seal(.rejected(error))
    }

}</code></pre>
<p>上面的<code>Resolver</code>的扩展，就是用不同的值给<code>Resolver</code>内置的盒子封箱，除了具体的值外，还可以封装一个<code>Result&lt;T&gt;</code>、<code>Optional</code>，值得注意的是当传递的是nil，<code>Resolver</code>会自动把它解析成<code>.rejected</code>。</p>
<pre><code class="swift">/// Resolves the promise with the provided value or error
func resolve(_ obj: T?, _ error: Error?) {
    if let error = error {
        reject(error)
    } else if let obj = obj {
        fulfill(obj)
    } else {
        reject(PMKError.invalidCallingConvention)
    }
}

/// Fulfills the promise with the provided value unless the provided error is non-nil
func resolve(_ obj: T, _ error: Error?) {
    if let error = error {
        reject(error)
    } else {
        fulfill(obj)
    }
}</code></pre>
<h4 id="Promise-swift"><a href="#Promise-swift" class="headerlink" title="Promise.swift"></a>Promise.swift</h4><pre><code>public final class Promise&lt;T&gt;: Thenable, CatchMixin {
    let box: Box&lt;Result&lt;T&gt;&gt;
}</code></pre><p>Promise遵守了两个协议<code>Thenable</code>和<code>CatchMixin</code>，<code>Thenable</code>提供了用于串联Promise的接口操作，跟<code>Resolver</code>一样，Promise也持有了<code>Box&lt;Result&lt;T&gt;&gt;</code>，这个属性会注入到<code>Resolver</code>，用于处理异步操作的结果。</p>
<p>Promise的resolver init方法允许我们指定一个动态生成“盒子值”的过程</p>
<pre><code class="Swift">public init(resolver body: (Resolver&lt;T&gt;) throws -&gt; Void) {
  box = EmptyBox()
  let resolver = Resolver(box)
  do {
    try body(resolver)
  } catch {
    resolver.reject(error)
  }
}</code></pre>
<p>以下是 example：</p>
<pre><code class="swift">public func load() -&gt; Promise&lt;UserSession&gt; {
  return Promise&lt;UserSession&gt; {
    resolver in
    do {
      let userSession = try loadUserSession()
      resolver.fulfill(userSession)
    }
    catch {
      resolver.reject(error)
    }
  }
}</code></pre>
<p>可以看到，这个根据loadUserSession的结果分别调用fullfill和reject的闭包，就是init的body参数。</p>
<p>在init(resolver:)的实现里，定义了一个EmptyBox对象，并用它创建了一个Resolver。然后用这个resolver对象作为body回调的参数，因此就可以load的中的闭包调用fulfill和reject的原因。</p>
<h4 id="Thenable"><a href="#Thenable" class="headerlink" title="Thenable"></a>Thenable</h4><p>Protocol Thenable，它约定了串联Promise对象的各种后续操作。</p>
<pre><code class="swift">/// Thenable represents an asynchronous operation that can be chained.
public protocol Thenable: class {
    /// The type of the wrapped value
    associatedtype T

    /// `pipe` is immediately executed when this `Thenable` is resolved
    func pipe(to: @escaping(Result&lt;T&gt;) -&gt; Void)

    /// The resolved result or nil if pending.
    var result: Result&lt;T&gt;? { get }
}</code></pre>
<p>关联类型T,可以理解为Promise中包装的类型，例如Promise<UserSession>中，T的类型就是UserSession。</p>
<p>在Promise.swift中可以看到var result: Result<T>?的实现逻辑，在Promise里，box中封装的类型是Result<T>，result的作用就是当”盒子”已经密封好的时候，把它的值取出来，如果是pending(没有密封好的时候)，否则返回nil。</p>
<pre><code class="swift">/// - See: `Thenable.result`
public var result: Result&lt;T&gt;? {
    switch box.inspect() {
    case .pending:
        return nil
    case .resolved(let result):
        return result
    }
}</code></pre>
<h4 id="Thenable的扩展"><a href="#Thenable的扩展" class="headerlink" title="Thenable的扩展"></a>Thenable的扩展</h4><p>通过Thenable的一系列扩展接口来实现”Promise”串联操作。</p>
<pre><code class="swift">public func then&lt;U&gt;(
    on: DispatchQueue? = conf.Q.map,
    flags: DispatchWorkItemFlags? = nil,
    _ body: @escaping (Self.T) throws -&gt; U) -&gt; PromiseKit.Promise&lt;U.T&gt; where U : PromiseKit.Thenable</code></pre>
<p><strong>on</strong>表示then串联的闭包执行的队列，它有一个默认值，是在主线程;</p>
<p><strong>flag</strong>表示队列中任务的配置，默认是nil;</p>
<p><strong>body</strong>就是在Promise对象之后，串联的closure，用Promise中封装的值作为闭包的参数，返回值U是一个新的遵从Thenable的类型，通常我们会返回一个新的Promise类型或者Guarantee对象。</p>
<p>then 函数返回的是一个新的Promise，这个Promise封装的值就是body参数中返回的U中的关联类型。</p>
<h4 id="then的实现"><a href="#then的实现" class="headerlink" title="then的实现"></a><code>then</code>的实现</h4><pre><code class="swift">func then&lt;U: Thenable&gt;(on: DispatchQueue? = conf.Q.map, flags: DispatchWorkItemFlags? = nil, _ body: @escaping(T) throws -&gt; U) -&gt; Promise&lt;U.T&gt; {
    let rp = Promise&lt;U.T&gt;(.pending)
    pipe {
        switch $0 {
        case .fulfilled(let value):
            on.async(flags: flags) {
                do {
                    let rv = try body(value)
                    guard rv !== rp else { throw PMKError.returnedSelf }
                    rv.pipe(to: rp.box.seal)
                } catch {
                    rp.box.seal(.rejected(error))
                }
            }
        case .rejected(let error):
            rp.box.seal(.rejected(error))
        }
    }
    return rp
}</code></pre>
<p>首先创建了一个返回值为Promise&lt;U.T&gt;:</p>
<pre><code>let rp = Promise&lt;U.T&gt;(.pending)  // Promise&lt;U.T&gt;.init(.pending)</code></pre><p>.pending创建的不是一个Box，实际上是调用了以下的init方法</p>
<pre><code class="swift">init(_: PMKUnambiguousInitializer) {
  box = EmptyBox()
}</code></pre>
<p>以上方法创建了一个空的盒子，这个盒子将要封装的值类型就是Result&lt;U.T&gt;。</p>
<p>接下来就是pipe方法的调用，这个方法可以大概理解为当上游的Promise的期望达成之后，就调用then提供的闭包。</p>
<pre><code class="swift">public func pipe(to: @escaping(Result&lt;T&gt;) -&gt; Void) {
    switch box.inspect() { 
    case .pending:
        box.inspect {
            switch $0 {
            case .pending(let handlers):
                handlers.append(to)
            case .resolved(let value):
                to(value)
            }
        }
    case .resolved(let value):
        to(value)
    }
}
</code></pre>
<p> <code>box.inspect</code>读取了当前Promise中盒子的状态，如果box是resolved状态则直接把这个值传递给pipe的closure方法，如果是还在等待异步操作的结果，则调用box的另外的一个inspect版本，这个版本的 <code>box.inspect</code>会把当前Box的状态，传递给<code>inspect</code>的closure参数，并执行这个closure。</p>
<p>如果此时Promise还未得到期望的结果，就会把pipe的closure加入到handlers里面，否则则直接执行<code>to(value)</code>，所以当Promise一旦得到期望的结果就立即回调用pipe提供的closure执行。</p>
<p>在了解pipe函数之后，再来看一下then函数中对pipe的使用</p>
<pre><code class="swift">pipe {
    switch $0 {
    case .fulfilled(let value):
        on.async(flags: flags) {
            do {
                let rv = try body(value)
                guard rv !== rp else { throw PMKError.returnedSelf }
                rv.pipe(to: rp.box.seal)
            } catch {
                rp.box.seal(.rejected(error))
            }
        }
    case .rejected(let error):
        rp.box.seal(.rejected(error))
    }
}
</code></pre>
<p>在这个pipe的闭包里面，首先会检查Promise对象传递过来的Result&lt;T&gt;对象，如果Result包含的是错误，则提取这个错误并封装到rp.box中，否则Result&lt;T&gt;对象包含的是成功执行的结果。do里面的body(value)就是在执行提供给then的closure。</p>
<p>重点是在对<code>rv.pipe(to: rp.box.seal)</code>的理解上，<code>rv.pipe</code>的closure参数，会在rv持有的box被密封的时候调用，而调用时，传递给<code>rp.box.seal</code>的参数就是<code>rv</code>被resolve时所封装的结果，即一个<code>Result&lt;U.T&gt;</code>对象，这就是可以一直wrapper串联各种操作的原因。</p>
<h4 id="Promise框架总结"><a href="#Promise框架总结" class="headerlink" title="Promise框架总结"></a>Promise框架总结</h4><h5 id="一-创建一个Promise-lt-T-gt-的步骤"><a href="#一-创建一个Promise-lt-T-gt-的步骤" class="headerlink" title="一.创建一个Promise&lt;T&gt;的步骤"></a>一.创建一个Promise&lt;T&gt;的步骤</h5><p><img src="https://raw.githubusercontent.com/CathyLy/imageForSource/master/2020/promise.png" alt="promise"></p>
<ul>
<li><p>首先调用了Promise的init方法</p>
<pre><code class="swift">public init(resolver body: (Resolver&lt;T&gt;) throws -&gt; Void) {
    box = EmptyBox()
    let resolver = Resolver(box)
    do {
        try body(resolver)
    } catch {
        resolver.reject(error)
    }
}</code></pre>
</li>
</ul>
<ul>
<li><p>其次在<code>init</code>方法中创建了一个<code>.pending</code>状态的空盒子，这个盒子有两个属性：一个是用于同步盒子状态的队列，另一个是处理Promise值的Handlers数组：</p>
<pre><code>class EmptyBox&lt;T&gt;: Box&lt;T&gt; {
    private var sealant = Sealant&lt;T&gt;.pending(Handlers.init())
    private let barrier = DispatchQueue(label: &quot;org.promisekit.barrier&quot;, attributes: .concurrent)
}</code></pre></li>
<li><p>第三，用上一步创建的盒子，创建一个<code>Resolver</code>对象，<code>Resolver</code>是PromiseKit为我们处理事件提供的接口。</p>
</li>
<li><p>第四，调用传递给<code>init</code>方法的闭包，这个闭包里面的代码有可能是同步执行也有可能是异步执行，具体取决于具体的逻辑，如果这个闭包抛出异常，PromiseKit会自动调用<code>resolver.reject(error)</code>，否则则需要在编写的闭包里面，根据代码执行的结果进行<code>resolver.fulfill(value)</code>或者<code>resolver.reject(error)</code>。这也是PromiseKit里面唯一有可能包含闭包嵌套的地方。</p>
</li>
<li><p>第五，无论是<code>fulfill</code>还是<code>reject</code>，它们背后的操作都是把特定的值封装在<code>Resolver</code>内部的盒子里。</p>
</li>
<li><p>最后，在<code>seal</code>的方法里面，如果盒子已经<code>resolved</code>，则直接返回，如果盒子的状态是<code>.pending</code>则把盒子设置为<code>.resolved</code>状态并一一调用每一个处理Promise期望值的handler。</p>
<pre><code>override func seal(_ value: T) {
    var handlers: Handlers&lt;T&gt;!
    barrier.sync(flags: .barrier) {
        guard case .pending(let _handlers) = self.sealant else {
            return  // already fulfilled!
        }
        handlers = _handlers
        self.sealant = .resolved(value)
    }
    if let handlers = handlers {
        handlers.bodies.forEach{ $0(value) }
    }
}
</code></pre></li>
</ul>
<h5 id="二-Promise的Wrapper操作"><a href="#二-Promise的Wrapper操作" class="headerlink" title="二.Promise的Wrapper操作"></a>二.Promise的Wrapper操作</h5><p><img src="https://raw.githubusercontent.com/CathyLy/imageForSource/master/2020/promise-wrapper.png" alt="image-20200121211615087"></p>
<p>上面的图重点在于<code>then</code>方法实现里面</p>
<ul>
<li><p>首先直接创建了它的返回值，一个<code>Promise&lt;U.T&gt;</code>对象，这个<code>Promise</code>里面包含的是一个等待密封的空盒子</p>
</li>
<li><p>创建好盒子之后，调用了<code>Promise.pipe</code>方法</p>
<pre><code>public func pipe(to: @escaping(Result&lt;T&gt;) -&gt; Void) {
    switch box.inspect() {
    case .pending:
        box.inspect {
            switch $0 {
            case .pending(let handlers):
                handlers.append(to)
            case .resolved(let value):
                to(value)
            }
        }
    case .resolved(let value):
        to(value)
    }
}
</code></pre><p>这个方法里面有5个关键点，前两个是两次调用了<code>box.inspect</code>方法，这两次调用都会向上游的<code>Promise.box</code>自带的队列里添加两个任务。</p>
<p>后三个是对<code>to</code>的引用，第一处是如果Promise是<code>.pending</code>则<code>pipe</code>的参数（闭包）添加到上游的<code>Promise.box</code>的<code>Handlers</code>的关联值中，后两处是如果Promise已经被<code>.resolved</code>则直接调用<code>pipe</code>的闭包参数</p>
</li>
<li><p>then的<code>pipe</code>回调中，有4处关键点：第一，<code>try body(value)</code>这是是真正调用外部给<code>then</code>传递的闭包的地方；</p>
<pre><code>pipe {
  switch $0 {
  case .fulfilled(let value):
    on.async(flags: flags) {
      do {
        let rv = try body(value)
        guard rv !== rp else { throw PMKError.returnedSelf }
        rv.pipe(to: rp.box.seal)
      } catch {
        rp.box.seal(.rejected(error))
      }
    }
  case .rejected(let error):
    rp.box.seal(.rejected(error))
  }
}</code></pre><p>后三处分别以下三行代码：</p>
<pre><code>rv.pipe(to: rp.box.seal)
rp.box.seal(.rejected(error))
rp.box.seal(.rejected(error))</code></pre><p><code>rv</code>是<code>body(value)</code>的返回值，<code>rp</code>是<code>then</code>要返回的<code>Promise</code>对象，后两行代码主要功能是无论上游<code>Promise</code>发生了什么错误，还是说外部提供给<code>then</code>的闭包发生了异常，都要给<code>rp</code>的盒子密封上错误的value。</p>
<p>如果没有发生任何异常，<code>rp</code>中的值则依赖<code>body</code>的实现：如果<code>body</code>中调用<code>fulfill</code>就封装成功的值，调用<code>reject</code>就封装错误的值。</p>
<p>最后，把<code>rp</code>的封箱过程，交由<code>rv</code>来处理，等<code>rv</code>持有的盒子被密封了，就可以返回了。</p>
</li>
</ul>
<h4 id="when"><a href="#when" class="headerlink" title="when"></a>when</h4><pre><code class="swift">let getUserAssets = getUserAssets(session: session)
let getUserMarginAssetsDetails = getMarginAccountDetails(session: session)
let getUserMarginCoeff = getUserMarginCoeff(session: session)
let getAccountProfit =getAccountProfit(session: session, period: time)

when(fulfilled: getUserAssets, getUserMarginAssetsDetails, getUserMarginCoeff, getAccountProfit)
.map({ (userAssets, userMarginAssetsDetails, userMarginCoeff, profits) -&gt; MarginFundsState in
    return MarginFundsState(userAssets: userAssets, userMarginAssetsDetails: userMarginAssetsDetails, userMarginCoeff: userMarginCoeff, profits: profits)
})</code></pre>
<p><code>when</code>表示多个异步操作同时处理，当<code>when</code>中的操作都完成时再返回Promise结果。</p>
<pre><code class="swift">public func when&lt;U: Thenable&gt;(fulfilled thenables: [U]) -&gt; Promise&lt;[U.T]&gt; 
public func when&lt;T&gt;(resolved promises: Promise&lt;T&gt;...) -&gt; Guarantee&lt;[Result&lt;T&gt;]&gt;
public func race&lt;U: Thenable&gt;(_ thenables: U...) -&gt; Promise&lt;U.T&gt;</code></pre>
<ul>
<li><code>when(fulfilled:)</code>在所有异步操作都执行完成之后再回调，</li>
<li><code>when(resolved: )</code>是使一个或多个Promise失败也会等待，此<code>when</code>变体返回的值是一个<code>[Result&lt;T&gt;]</code>的数组，所有要保证是相同的泛型。</li>
<li><code>race()</code>表示的是只有有一个异步操作完成则立刻调用<code>then</code>的回调，其他没有执行完毕的异步操作会继续执行，不会停止。</li>
</ul>
<pre><code class="swift">/// Wait for all promises in a set to fulfill.
public func when&lt;U: Thenable, V: Thenable, W: Thenable, X: Thenable, Y: Thenable&gt;(
    fulfilled pu: U, _ pv: V, _ pw: W, _ px: X, _ py: Y) -&gt; Promise&lt;(U.T, V.T, W.T, X.T, Y.T)&gt; {
    return _when([pu.asVoid(), pv.asVoid(), pw.asVoid(), px.asVoid(), py.asVoid()])
        .map(on: nil) { (pu.value!, pv.value!, pw.value!, px.value!, py.value!) }
}</code></pre>
<p>从上面的when的函数可以看出，<code>when(fulfilled:)</code>PromiseKit目前最多支持同时五个异步不同Promise操作。</p>
<p>以上就是整个PromiseKit的源码分析。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liututu1213</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liututu1213</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
